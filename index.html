<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beframe - Editor de Imagens com Moldura</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .logo {
            width: 200px;
            max-width: 25%;
            height: auto;
            display: block;
            margin: 0 auto 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .upload-box {
            border: 3px dashed #191e31;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
            position: relative;
        }

        .upload-box:hover {
            border-color: #5568d3;
            background: #f0f2ff;
            transform: translateY(-5px);
        }

        .upload-box.has-file {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .upload-box .icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .upload-box h3 {
            color: #191e31;
            margin-bottom: 15px;
        }

        .upload-box.has-file h3 {
            color: #10b981;
        }

        input[type="file"] {
            display: none;
        }

        .preview-section {
            display: none;
            margin-top: 30px;
        }

        .preview-section.active {
            display: block;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f1f5f9;
            border-radius: 15px;
        }

        .tool-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            color: #334155;
        }

        .tool-btn:hover {
            background: #e2e8f0;
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: #1e293b;
            color: white;
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }

        select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            background: white;
        }

        input[type="text"],
        input[type="range"] {
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider {
            width: 150px;
        }

        /* Canvas */
        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            position: relative;
        }

        #canvas {
            max-width: 100%;
            height: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: block;
            margin: 0 auto;
            cursor: grab;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        /* Buttons */
        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            margin: 10px;
            font-weight: 600;
        }

        .btn-primary {
            background: #10b981;
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-primary:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
        }

        .btn-secondary {
            background: #191e31;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary:hover {
            background: #5568d3;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .button-group {
            text-align: center;
            margin-top: 20px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            padding: 20px;
            overflow: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            font-size: 1.5em;
            color: #333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
            line-height: 1;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .close-btn:hover {
            color: #333;
        }

        .modal-canvas-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        #cropCanvas,
        #eraserCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .modal-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        /* Filename section */
        .filename-section {
            background: #f8f9ff;
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .filename-inputs {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .filename-preview {
            background: white;
            border: 2px solid #10b981;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .filename-preview-text {
            font-family: monospace;
            font-size: 16px;
            color: #10b981;
            font-weight: bold;
        }

        /* Info section */
        .info {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .hint {
            background: #fef3c7;
            color: #92400e;
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .hint.blue {
            background: #dbeafe;
            color: #1e40af;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
            
            .filename-inputs {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                width: 100%;
            }
            
            .control-group {
                width: 100%;
            }
            
            select, input[type="text"] {
                width: 100%;
            }
            
            .btn {
                width: 100%;
                margin: 5px 0;
            }
            
            .toolbar {
                flex-wrap: wrap;
            }
            
            .tool-btn {
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://vituchoa.github.io/moldura/src/logo_beframe.png" alt="Beframe" class="logo">
        
        <div class="upload-section">
            <div class="upload-box" id="imageBox" onclick="document.getElementById('imageUpload').click()">
                <div class="icon">üì∑</div>
                <h3 id="imageLabel">Sua Imagem</h3>
                <p>Clique ou arraste a imagem aqui</p>
                <input type="file" id="imageUpload" accept="image/*">
            </div>

            <div class="upload-box" id="frameBox" onclick="document.getElementById('frameUpload').click()">
                <div class="icon">üñºÔ∏è</div>
                <h3 id="frameLabel">Moldura PNG</h3>
                <p>Clique ou arraste a moldura aqui<br>(PNG com transpar√™ncia)</p>
                <input type="file" id="frameUpload" accept="image/png">
            </div>
        </div>

        <div class="preview-section" id="previewSection">
            <!-- Toolbar -->
            <div class="toolbar">
                <button class="tool-btn active" id="moveTool" onclick="setTool('move')">
                    üñêÔ∏è Mover
                </button>
                <button class="tool-btn" id="cropTool" onclick="openCropModal()">
                    ‚úÇÔ∏è Cortar
                </button>
                <button class="tool-btn" id="eraserTool" onclick="openEraserModal()">
                    üßπ Borracha
                </button>
            </div>

            <!-- Controls -->
            <div class="controls">
                <div class="control-group">
                    <label>Modo de Ajuste</label>
                    <select id="fitMode" onchange="render()">
                        <option value="cover">Cobrir (sem bordas)</option>
                        <option value="contain">Conter (completa)</option>
                        <option value="fill">Preencher (esticar)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Cor de Fundo</label>
                    <select id="bgMode" onchange="render()">
                        <option value="dominant">Autom√°tico</option>
                        <option value="white">Branco</option>
                        <option value="black">Preto</option>
                        <option value="custom">Personalizado</option>
                    </select>
                </div>

                <div class="control-group" id="customColorGroup" style="display: none;">
                    <label>Cor Personalizada</label>
                    <input type="text" id="customColor" value="#FFFFFF" maxlength="7" onchange="render()">
                </div>

                <div class="control-group">
                    <label>Zoom: <span id="zoomValue">100</span>%</label>
                    <div class="slider-container">
                        <input type="range" id="zoomSlider" class="slider" min="50" max="200" value="100" oninput="updateZoom(this.value)">
                    </div>
                </div>
            </div>

            <div class="hint blue" id="moveHint">
                üñêÔ∏è Arraste a imagem para reposicion√°-la dentro da moldura
            </div>

            <!-- Canvas -->
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <!-- Filename section -->
            <div class="filename-section">
                <h3 style="text-align: center; margin-bottom: 15px;">üìù Nomenclatura do Arquivo</h3>
                <div class="filename-inputs">
                    <div class="control-group">
                        <label>Prefixo</label>
                        <input type="text" id="filePrefix" placeholder="ex: artigo" oninput="updateFilenamePreview()">
                    </div>
                    <div class="control-group">
                        <label>Nome do Arquivo</label>
                        <input type="text" id="articleName" placeholder="ex: titulo-do-meu-artigo" oninput="updateFilenamePreview()">
                    </div>
                </div>
                <div class="filename-preview">
                    <label style="font-size: 12px; color: #666;">üìÑ Nome final:</label>
                    <div class="filename-preview-text" id="filenamePreview">
                        Digite o nome do artigo
                    </div>
                </div>
            </div>

            <!-- Buttons -->
            <div class="button-group">
                <button class="btn btn-primary" onclick="downloadImage()">
                    ‚¨áÔ∏è Baixar Imagem
                </button>
                <button class="btn btn-secondary" onclick="resetAll()">
                    üîÑ Gerar Nova Imagem
                </button>
            </div>
        </div>

        <div class="info">
            <strong>Como funciona:</strong><br>
            1. Fa√ßa upload de sua imagem e moldura PNG<br>
            2. Arraste para posicionar, use zoom para ajustar<br>
            3. Use corte ou borracha para editar a imagem<br>
            4. Baixe o resultado final em alta resolu√ß√£o
            <br><br><strong>Beframe by Beside Media - 2026</strong>
        </div>
    </div>

    <!-- Crop Modal -->
    <div class="modal" id="cropModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚úÇÔ∏è Recortar Imagem</h2>
                <button class="close-btn" onclick="closeCropModal()">√ó</button>
            </div>
            <p style="color: #666; margin-bottom: 20px;">Arraste para mover a √°rea de corte. Use os cantos para redimensionar.</p>
            <div class="modal-canvas-container">
                <canvas id="cropCanvas"></canvas>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="resetCrop()">üîÑ Resetar</button>
                <button class="btn btn-secondary" onclick="closeCropModal()">‚ùå Cancelar</button>
                <button class="btn btn-primary" onclick="applyCrop()">‚úÖ Aplicar</button>
            </div>
        </div>
    </div>

    <!-- Eraser Modal -->
    <div class="modal" id="eraserModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üßπ Borracha</h2>
                <button class="close-btn" onclick="closeEraserModal()">√ó</button>
            </div>
            <p style="color: #666; margin-bottom: 15px;">Arraste sobre a imagem para apagar elementos.</p>
            <div class="control-group" style="margin-bottom: 20px;">
                <label>Tamanho da Borracha: <span id="brushSizeValue">30</span>px</label>
                <input type="range" id="brushSize" min="5" max="100" value="30" style="width: 100%;" oninput="updateBrushSize(this.value)">
            </div>
            <div class="modal-canvas-container">
                <canvas id="eraserCanvas"></canvas>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="undoEraser()">‚Ü©Ô∏è Desfazer</button>
                <button class="btn btn-secondary" onclick="resetEraser()">üîÑ Resetar</button>
                <button class="btn btn-secondary" onclick="closeEraserModal()">‚ùå Cancelar</button>
                <button class="btn btn-primary" onclick="applyEraser()">‚úÖ Aplicar</button>
            </div>
        </div>
    </div>

    <script>
        // Estado global
        let uploadedImage = null;
        let frameImage = null;
        let transparentArea = null;
        let dominantColor = '#FFFFFF';
        let zoom = 100;
        let imageOffset = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentTool = 'move';
        let croppedImage = null;
        let erasedImageData = null;

        // Crop modal state
        let cropArea = null;
        let cropIsDragging = false;
        let cropIsResizing = false;
        let cropResizeHandle = null;
        let cropDragStart = { x: 0, y: 0 };

        // Eraser modal state
        let eraserHistory = [];
        let eraserIsErasing = false;
        let brushSize = 30;

        // Upload handlers
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        uploadedImage = img;
                        croppedImage = null;
                        erasedImageData = null;
                        imageOffset = { x: 0, y: 0 };
                        zoom = 100;
                        document.getElementById('imageBox').classList.add('has-file');
                        document.getElementById('imageLabel').textContent = '‚úì Imagem Carregada';
                        extractDominantColor(img);
                        if (frameImage && transparentArea) {
                            render();
                            document.getElementById('previewSection').classList.add('active');
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('frameUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        frameImage = img;
                        document.getElementById('frameBox').classList.add('has-file');
                        document.getElementById('frameLabel').textContent = '‚úì Moldura Carregada';
                        detectTransparentArea(img);
                        if (uploadedImage) {
                            render();
                            document.getElementById('previewSection').classList.add('active');
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Detect transparent area
        function detectTransparentArea(img) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.naturalWidth;
            tempCanvas.height = img.naturalHeight;
            tempCtx.drawImage(img, 0, 0);
            
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
            
            for (let y = 0; y < tempCanvas.height; y++) {
                for (let x = 0; x < tempCanvas.width; x++) {
                    const alpha = data[(y * tempCanvas.width + x) * 4 + 3];
                    if (alpha < 180) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            const margin = 3;
            transparentArea = {
                x: Math.max(0, minX - margin),
                y: Math.max(0, minY - margin),
                width: Math.min(tempCanvas.width, maxX - minX + (margin * 2)),
                height: Math.min(tempCanvas.height, maxY - minY + (margin * 2))
            };
        }

        // Extract dominant color
        function extractDominantColor(img) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const size = 50;
            tempCanvas.width = size;
            tempCanvas.height = size;
            tempCtx.drawImage(img, 0, 0, size, size);
            
            const imageData = tempCtx.getImageData(0, 0, size, size);
            const data = imageData.data;
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 128) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    count++;
                }
            }
            
            if (count > 0) {
                r = Math.floor(r / count);
                g = Math.floor(g / count);
                b = Math.floor(b / count);
                dominantColor = rgbToHex(r, g, b);
            }
        }

        function rgbToHex(r, g, b) {
            return "#" + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }

        // Get current image (prioritize erased > cropped > original)
        function getCurrentImage() {
            if (erasedImageData) {
                const img = new Image();
                img.src = erasedImageData;
                return img;
            }
            if (croppedImage) return croppedImage;
            return uploadedImage;
        }

        // Render main canvas
        function render() {
            const currentImage = getCurrentImage();
            if (!currentImage || !frameImage || !transparentArea) return;

            // Wait for erased image to load
            if (erasedImageData && !currentImage.complete) {
                currentImage.onload = render;
                return;
            }

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = frameImage.naturalWidth;
            canvas.height = frameImage.naturalHeight;

            // Background
            const bgMode = document.getElementById('bgMode').value;
            let bgColor = '#FFFFFF';
            if (bgMode === 'dominant') bgColor = dominantColor;
            else if (bgMode === 'black') bgColor = '#000000';
            else if (bgMode === 'white') bgColor = '#FFFFFF';
            else if (bgMode === 'custom') bgColor = document.getElementById('customColor').value;

            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate image position
            const fitMode = document.getElementById('fitMode').value;
            const targetWidth = transparentArea.width;
            const targetHeight = transparentArea.height;
            const imgRatio = currentImage.naturalWidth / currentImage.naturalHeight;
            const targetRatio = targetWidth / targetHeight;
            const zoomFactor = zoom / 100;

            let drawWidth, drawHeight;
            if (fitMode === 'cover') {
                if (imgRatio > targetRatio) {
                    drawHeight = targetHeight;
                    drawWidth = drawHeight * imgRatio;
                } else {
                    drawWidth = targetWidth;
                    drawHeight = drawWidth / imgRatio;
                }
            } else if (fitMode === 'contain') {
                if (imgRatio > targetRatio) {
                    drawWidth = targetWidth;
                    drawHeight = drawWidth / imgRatio;
                } else {
                    drawHeight = targetHeight;
                    drawWidth = drawHeight * imgRatio;
                }
            } else {
                drawWidth = targetWidth;
                drawHeight = targetHeight;
            }

            drawWidth *= zoomFactor;
            drawHeight *= zoomFactor;

            const drawX = transparentArea.x + (targetWidth - drawWidth) / 2 + imageOffset.x;
            const drawY = transparentArea.y + (targetHeight - drawHeight) / 2 + imageOffset.y;

            ctx.drawImage(currentImage, drawX, drawY, drawWidth, drawHeight);
            ctx.drawImage(frameImage, 0, 0, canvas.width, canvas.height);
        }

        // Show/hide custom color input
        document.getElementById('bgMode').addEventListener('change', function() {
            const customGroup = document.getElementById('customColorGroup');
            customGroup.style.display = this.value === 'custom' ? 'block' : 'none';
        });

        // Zoom control
        function updateZoom(value) {
            zoom = parseInt(value);
            document.getElementById('zoomValue').textContent = zoom;
            render();
        }

        // Tool selection
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
            
            const hint = document.getElementById('moveHint');
            hint.style.display = tool === 'move' ? 'block' : 'none';
        }

        // Canvas drag
        const canvas = document.getElementById('canvas');
        canvas.addEventListener('mousedown', function(e) {
            if (currentTool !== 'move') return;
            isDragging = true;
            const rect = canvas.getBoundingClientRect();
            dragStart = {
                x: e.clientX - rect.left - imageOffset.x,
                y: e.clientY - rect.top - imageOffset.y
            };
            canvas.classList.add('grabbing');
        });

        canvas.addEventListener('mousemove', function(e) {
            if (!isDragging || currentTool !== 'move') return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            imageOffset = {
                x: (e.clientX - rect.left - dragStart.x) * scaleX,
                y: (e.clientY - rect.top - dragStart.y) * scaleY
            };
            render();
        });

        canvas.addEventListener('mouseup', function() {
            isDragging = false;
            canvas.classList.remove('grabbing');
        });

        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
            canvas.classList.remove('grabbing');
        });

        // Touch support
        canvas.addEventListener('touchstart', function(e) {
            if (currentTool !== 'move') return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            isDragging = true;
            dragStart = {
                x: touch.clientX - rect.left - imageOffset.x,
                y: touch.clientY - rect.top - imageOffset.y
            };
        });

        canvas.addEventListener('touchmove', function(e) {
            if (!isDragging || currentTool !== 'move') return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            imageOffset = {
                x: (touch.clientX - rect.left - dragStart.x) * scaleX,
                y: (touch.clientY - rect.top - dragStart.y) * scaleY
            };
            render();
        });

        canvas.addEventListener('touchend', function() {
            isDragging = false;
        });

        // ===== CROP MODAL =====
        function openCropModal() {
            if (!uploadedImage && !croppedImage) return;
            
            const modal = document.getElementById('cropModal');
            const canvas = document.getElementById('cropCanvas');
            const ctx = canvas.getContext('2d');
            
            const img = croppedImage || uploadedImage;
            const maxWidth = Math.min(800, window.innerWidth - 48);
            const maxHeight = window.innerHeight - 300;
            const scale = Math.min(maxWidth / img.naturalWidth, maxHeight / img.naturalHeight, 1);
            
            canvas.width = img.naturalWidth * scale;
            canvas.height = img.naturalHeight * scale;
            canvas.style.maxWidth = '100%';
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Initialize crop area
            const cropW = canvas.width * 0.8;
            const cropH = canvas.height * 0.8;
            cropArea = {
                x: (canvas.width - cropW) / 2,
                y: (canvas.height - cropH) / 2,
                width: cropW,
                height: cropH,
                scale: scale
            };
            
            drawCropOverlay();
            modal.classList.add('active');
            
            // Add event listeners
            canvas.addEventListener('mousedown', cropMouseDown);
            canvas.addEventListener('mousemove', cropMouseMove);
            canvas.addEventListener('mouseup', cropMouseUp);
        }

        function closeCropModal() {
            const modal = document.getElementById('cropModal');
            const canvas = document.getElementById('cropCanvas');
            modal.classList.remove('active');
            
            canvas.removeEventListener('mousedown', cropMouseDown);
            canvas.removeEventListener('mousemove', cropMouseMove);
            canvas.removeEventListener('mouseup', cropMouseUp);
        }

        function drawCropOverlay() {
            const canvas = document.getElementById('cropCanvas');
            const ctx = canvas.getContext('2d');
            const img = croppedImage || uploadedImage;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, cropArea.y);
            ctx.fillRect(0, cropArea.y + cropArea.height, canvas.width, canvas.height - cropArea.y - cropArea.height);
            ctx.fillRect(0, cropArea.y, cropArea.x, cropArea.height);
            ctx.fillRect(cropArea.x + cropArea.width, cropArea.y, canvas.width - cropArea.x - cropArea.width, cropArea.height);
            
            // Border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
            
            // Handles
            ctx.fillStyle = '#fff';
            const handleSize = 12;
            [[cropArea.x, cropArea.y], [cropArea.x + cropArea.width, cropArea.y],
             [cropArea.x, cropArea.y + cropArea.height], [cropArea.x + cropArea.width, cropArea.y + cropArea.height]]
            .forEach(([hx, hy]) => {
                ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
            });
        }

        function cropMouseDown(e) {
            const canvas = document.getElementById('cropCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const handle = getCropHandle(x, y);
            if (handle) {
                cropIsResizing = true;
                cropResizeHandle = handle;
                cropDragStart = { x, y };
            } else if (isInsideCropArea(x, y)) {
                cropIsDragging = true;
                cropDragStart = { x: x - cropArea.x, y: y - cropArea.y };
            }
        }

        function cropMouseMove(e) {
            const canvas = document.getElementById('cropCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (cropIsDragging) {
                cropArea.x = Math.max(0, Math.min(canvas.width - cropArea.width, x - cropDragStart.x));
                cropArea.y = Math.max(0, Math.min(canvas.height - cropArea.height, y - cropDragStart.y));
                drawCropOverlay();
            } else if (cropIsResizing && cropResizeHandle) {
                const minSize = 50;
                let newCrop = { ...cropArea };
                
                switch (cropResizeHandle) {
                    case 'se':
                        newCrop.width = Math.max(minSize, x - cropArea.x);
                        newCrop.height = Math.max(minSize, y - cropArea.y);
                        break;
                    case 'sw':
                        newCrop.x = Math.min(x, cropArea.x + cropArea.width - minSize);
                        newCrop.width = Math.max(minSize, cropArea.x + cropArea.width - x);
                        newCrop.height = Math.max(minSize, y - cropArea.y);
                        break;
                    case 'ne':
                        newCrop.y = Math.min(y, cropArea.y + cropArea.height - minSize);
                        newCrop.width = Math.max(minSize, x - cropArea.x);
                        newCrop.height = Math.max(minSize, cropArea.y + cropArea.height - y);
                        break;
                    case 'nw':
                        newCrop.x = Math.min(x, cropArea.x + cropArea.width - minSize);
                        newCrop.y = Math.min(y, cropArea.y + cropArea.height - minSize);
                        newCrop.width = Math.max(minSize, cropArea.x + cropArea.width - x);
                        newCrop.height = Math.max(minSize, cropArea.y + cropArea.height - y);
                        break;
                }
                
                newCrop.x = Math.max(0, newCrop.x);
                newCrop.y = Math.max(0, newCrop.y);
                newCrop.width = Math.min(newCrop.width, canvas.width - newCrop.x);
                newCrop.height = Math.min(newCrop.height, canvas.height - newCrop.y);
                
                cropArea = newCrop;
                drawCropOverlay();
            }
        }

        function cropMouseUp() {
            cropIsDragging = false;
            cropIsResizing = false;
            cropResizeHandle = null;
        }

        function getCropHandle(x, y) {
            const handleSize = 20;
            const handles = {
                'nw': [cropArea.x, cropArea.y],
                'ne': [cropArea.x + cropArea.width, cropArea.y],
                'sw': [cropArea.x, cropArea.y + cropArea.height],
                'se': [cropArea.x + cropArea.width, cropArea.y + cropArea.height]
            };
            
            for (const [key, [hx, hy]] of Object.entries(handles)) {
                if (Math.abs(x - hx) < handleSize && Math.abs(y - hy) < handleSize) {
                    return key;
                }
            }
            return null;
        }

        function isInsideCropArea(x, y) {
            return x >= cropArea.x && x <= cropArea.x + cropArea.width &&
                   y >= cropArea.y && y <= cropArea.y + cropArea.height;
        }

        function resetCrop() {
            const canvas = document.getElementById('cropCanvas');
            const cropW = canvas.width * 0.8;
            const cropH = canvas.height * 0.8;
            cropArea = {
                ...cropArea,
                x: (canvas.width - cropW) / 2,
                y: (canvas.height - cropH) / 2,
                width: cropW,
                height: cropH
            };
            drawCropOverlay();
        }

        function applyCrop() {
            const img = croppedImage || uploadedImage;
            const scale = cropArea.scale;
            
            const originalCrop = {
                x: cropArea.x / scale,
                y: cropArea.y / scale,
                width: cropArea.width / scale,
                height: cropArea.height / scale
            };
            
            const croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = originalCrop.width;
            croppedCanvas.height = originalCrop.height;
            const ctx = croppedCanvas.getContext('2d');
            
            ctx.drawImage(img, originalCrop.x, originalCrop.y, originalCrop.width, originalCrop.height,
                         0, 0, originalCrop.width, originalCrop.height);
            
            const croppedImg = new Image();
            croppedImg.onload = function() {
                croppedImage = croppedImg;
                erasedImageData = null;
                imageOffset = { x: 0, y: 0 };
                zoom = 100;
                extractDominantColor(croppedImg);
                render();
                closeCropModal();
            };
            croppedImg.src = croppedCanvas.toDataURL('image/png');
        }

        // ===== ERASER MODAL =====
        function openEraserModal() {
            const currentImage = croppedImage || uploadedImage;
            if (!currentImage) return;
            
            const modal = document.getElementById('eraserModal');
            const canvas = document.getElementById('eraserCanvas');
            const ctx = canvas.getContext('2d');
            
            let img = currentImage;
            if (erasedImageData) {
                img = new Image();
                img.src = erasedImageData;
            }
            
            const initCanvas = (image) => {
                const maxWidth = Math.min(800, window.innerWidth - 48);
                const maxHeight = window.innerHeight - 350;
                const scale = Math.min(maxWidth / image.naturalWidth, maxHeight / image.naturalHeight, 1);
                
                canvas.width = image.naturalWidth;
                canvas.height = image.naturalHeight;
                canvas.style.width = (image.naturalWidth * scale) + 'px';
                canvas.style.height = (image.naturalHeight * scale) + 'px';
                
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                
                eraserHistory = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
                modal.classList.add('active');
                
                canvas.addEventListener('mousedown', eraserMouseDown);
                canvas.addEventListener('mousemove', eraserMouseMove);
                canvas.addEventListener('mouseup', eraserMouseUp);
            };
            
            if (img.complete) {
                initCanvas(img);
            } else {
                img.onload = () => initCanvas(img);
            }
        }

        function closeEraserModal() {
            const modal = document.getElementById('eraserModal');
            const canvas = document.getElementById('eraserCanvas');
            modal.classList.remove('active');
            
            canvas.removeEventListener('mousedown', eraserMouseDown);
            canvas.removeEventListener('mousemove', eraserMouseMove);
            canvas.removeEventListener('mouseup', eraserMouseUp);
        }

        function updateBrushSize(value) {
            brushSize = parseInt(value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        }

        function eraseAt(x, y) {
            const canvas = document.getElementById('eraserCanvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const actualBrushSize = brushSize * scaleX;
            
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(x, y, actualBrushSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function eraserMouseDown(e) {
            eraserIsErasing = true;
            const canvas = document.getElementById('eraserCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            eraseAt((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
        }

        function eraserMouseMove(e) {
            if (!eraserIsErasing) return;
            const canvas = document.getElementById('eraserCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            eraseAt((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
        }

        function eraserMouseUp() {
            if (eraserIsErasing) {
                const canvas = document.getElementById('eraserCanvas');
                const ctx = canvas.getContext('2d');
                eraserHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            }
            eraserIsErasing = false;
        }

        function undoEraser() {
            if (eraserHistory.length <= 1) return;
            eraserHistory.pop();
            const canvas = document.getElementById('eraserCanvas');
            const ctx = canvas.getContext('2d');
            ctx.putImageData(eraserHistory[eraserHistory.length - 1], 0, 0);
        }

        function resetEraser() {
            if (eraserHistory.length === 0) return;
            const canvas = document.getElementById('eraserCanvas');
            const ctx = canvas.getContext('2d');
            ctx.putImageData(eraserHistory[0], 0, 0);
            eraserHistory = [eraserHistory[0]];
        }

        function applyEraser() {
            const canvas = document.getElementById('eraserCanvas');
            erasedImageData = canvas.toDataURL('image/png');
            render();
            closeEraserModal();
        }

        // Filename
        function updateFilenamePreview() {
            const prefix = document.getElementById('filePrefix').value.trim();
            const articleName = document.getElementById('articleName').value.trim();
            const preview = document.getElementById('filenamePreview');
            
            if (!articleName) {
                preview.textContent = 'Digite o nome do artigo';
                return;
            }
            
            const cleanPrefix = prefix.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            const cleanArticle = articleName.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            
            let finalName = '';
            if (cleanPrefix && cleanArticle) {
                finalName = cleanPrefix + '-' + cleanArticle + '.png';
            } else if (cleanArticle) {
                finalName = cleanArticle + '.png';
            } else {
                finalName = 'Digite o nome do artigo';
            }
            
            preview.textContent = finalName;
        }

        function generateFileName() {
            const prefix = document.getElementById('filePrefix').value.trim();
            const articleName = document.getElementById('articleName').value.trim();
            
            if (!articleName) return 'imagem-enquadrada';
            
            const cleanPrefix = prefix.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            const cleanArticle = articleName.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            
            if (cleanPrefix && cleanArticle) return cleanPrefix + '-' + cleanArticle;
            if (cleanArticle) return cleanArticle;
            return 'imagem-enquadrada';
        }

        // Download
        function downloadImage() {
            const canvas = document.getElementById('canvas');
            const fileName = generateFileName();
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = fileName + '.png';
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }

        // Reset
        function resetAll() {
            uploadedImage = null;
            frameImage = null;
            transparentArea = null;
            croppedImage = null;
            erasedImageData = null;
            dominantColor = '#FFFFFF';
            zoom = 100;
            imageOffset = { x: 0, y: 0 };
            
            document.getElementById('imageUpload').value = '';
            document.getElementById('frameUpload').value = '';
            document.getElementById('filePrefix').value = '';
            document.getElementById('articleName').value = '';
            
            document.getElementById('imageBox').classList.remove('has-file');
            document.getElementById('frameBox').classList.remove('has-file');
            document.getElementById('imageLabel').textContent = 'Sua Imagem';
            document.getElementById('frameLabel').textContent = 'Moldura PNG';
            
            document.getElementById('previewSection').classList.remove('active');
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = 100;
            document.getElementById('fitMode').value = 'cover';
            document.getElementById('bgMode').value = 'dominant';
            
            updateFilenamePreview();
        }
    </script>
</body>
</html>

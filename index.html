<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beframe by Beside Media</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Funnel+Display:wght@300..800&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Funnel Display', sans-serif; background: url('https://vituchoa.github.io/moldura/src/fundo.png') center/cover no-repeat fixed; min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 20px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 2.5em; }
        .subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 1.1em; }
        .portal-selection { text-align: center; margin-bottom: 30px; padding: 20px; background: #f8f9ff; border-radius: 15px; border: 2px solid #e0e7ff; }
        .portal-selection label { display: block; font-size: 16px; font-weight: 600; color: #191e31; margin-bottom: 10px; }
        .portal-selection select { width: 100%; max-width: 400px; padding: 12px 20px; border: 2px solid #ddd; border-radius: 10px; font-size: 15px; font-family: inherit; background: white; cursor: pointer; transition: all 0.3s; }
        .portal-selection select:focus { outline: none; border-color: #191e31; box-shadow: 0 0 0 3px rgba(25, 30, 49, 0.1); }
        .upload-section { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 40px; }
        .upload-section.single-column { grid-template-columns: 1fr; }
        .upload-section.multiple-frames { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        .upload-box { border: 3px dashed #191e31; border-radius: 15px; padding: 40px 20px; text-align: center; cursor: pointer; transition: all 0.3s; background: #f8f9ff; position: relative; min-height: 200px; }
        .upload-box:hover { border-color: #5568d3; background: #f0f2ff; transform: translateY(-5px); }
        .upload-box.drag-over { border-color: #10b981; background: #ecfdf5; transform: translateY(-5px) scale(1.02); box-shadow: 0 10px 30px rgba(16, 185, 129, 0.2); }
        .upload-box.drag-over::after { content: 'üì• Solte aqui'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; font-weight: bold; color: #10b981; pointer-events: none; animation: bounce 0.5s ease infinite; }
        @keyframes bounce { 0%, 100% { transform: translate(-50%, -50%); } 50% { transform: translate(-50%, -60%); } }
        .upload-box h3 { color: #191e31; margin-bottom: 15px; }
        .upload-box p { color: #666; font-size: 14px; }
        .upload-box.has-file { border-color: #10b981; background: #f0fdf4; }
        .upload-box.has-file h3 { color: #10b981; }
        input[type="file"] { display: none; }
        .frame-quantity { text-align: center; margin: 20px 0; padding: 20px; background: #f0f7ff; border-radius: 10px; display: none; }
        .frame-quantity.active { display: block; }
        .frame-quantity label { display: block; margin-bottom: 10px; font-weight: 600; color: #191e31; }
        .quantity-buttons { display: flex; gap: 10px; justify-content: center; }
        .quantity-btn { padding: 10px 20px; border: 2px solid #ddd; border-radius: 8px; background: white; cursor: pointer; transition: all 0.3s; }
        .quantity-btn.active { background: #191e31; color: white; border-color: #191e31; }
        .preview-section { display: none; }
        .preview-section.active { display: block; }
        .canvas-container { text-align: center; margin-bottom: 20px; background: #f5f5f5; padding: 20px; border-radius: 10px; position: relative; overflow: hidden; }
        .canvas-wrapper { display: inline-block; position: relative; }
        #canvas { max-width: 100%; height: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.2); display: block; cursor: move; touch-action: none; }
        #canvas.eyedropper-mode { cursor: crosshair; }
        #canvas.crop-mode { cursor: crosshair; }
        .crop-overlay { position: absolute; border: 2px dashed #FF0000; background: rgba(255, 0, 0, 0.1); pointer-events: none; display: none; }
        .crop-overlay.active { display: block; }
        .controls { display: flex; gap: 20px; justify-content: center; align-items: center; margin-bottom: 20px; flex-wrap: wrap; }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        .control-group label { font-size: 14px; color: #666; font-weight: 600; }
        select, button { padding: 10px 15px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; cursor: pointer; background: white; font-family: inherit; }
        button { display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.3s; font-weight: 600; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .color-picker-group { display: flex; flex-direction: column; gap: 8px; }
        .color-picker-row { display: flex; gap: 10px; align-items: center; }
        .color-input { width: 120px; padding: 10px 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; font-family: monospace; text-transform: uppercase; background: white; }
        .color-input:focus { outline: none; border-color: #191e31; }
        .eyedropper-btn { background: #191e31; color: white; border: none; }
        .eyedropper-btn:hover { background: #5568d3; }
        .eyedropper-btn:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
        .eyedropper-btn.active { background: #10b981; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); } 50% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); } }
        .color-display { width: 40px; height: 40px; border-radius: 8px; border: 2px solid #ddd; cursor: pointer; flex-shrink: 0; transition: all 0.3s; }
        .color-display:hover { border-color: #191e31; transform: scale(1.05); }
        .filename-section { background: #f8f9ff; border: 2px solid #e0e7ff; border-radius: 15px; padding: 25px; margin-bottom: 20px; }
        .filename-section h3 { color: #191e31; margin-bottom: 15px; font-size: 18px; text-align: center; }
        .filename-inputs { display: grid; grid-template-columns: 1fr 2fr; gap: 15px; margin-bottom: 15px; }
        .filename-group { display: flex; flex-direction: column; gap: 8px; }
        .filename-group label { font-size: 13px; color: #666; font-weight: 600; }
        .filename-group input { padding: 12px 15px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; background: white; transition: all 0.3s; }
        .filename-group input:focus { outline: none; border-color: #191e31; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        .filename-group input::placeholder { color: #999; }
        .filename-preview { background: white; border: 2px solid #10b981; border-radius: 10px; padding: 15px; text-align: center; }
        .filename-preview label { font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 8px; }
        .filename-preview-text { font-family: monospace; font-size: 16px; color: #10b981; font-weight: bold; word-break: break-all; }
        .filename-preview-text .separator { color: #999; }
        .download-btn { background: #10b981; color: white; padding: 15px 40px; border: none; border-radius: 50px; font-size: 18px; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4); display: inline-block; margin: 10px; }
        .download-btn:hover { background: #059669; transform: translateY(-2px); box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6); }
        .new-btn { background: #191e31; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .new-btn:hover { background: #5568d3; box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6); }
        .edit-controls { display: flex; gap: 15px; justify-content: center; align-items: center; margin-bottom: 15px; flex-wrap: wrap; }
        .edit-btn { background: #8b5cf6; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 8px; }
        .edit-btn:hover { background: #7c3aed; }
        .edit-btn.active { background: #10b981; }
        .button-group { text-align: center; margin-top: 20px; }
        .info { text-align: center; color: #666; margin-top: 20px; font-size: 14px; line-height: 1.6; }
        .icon { font-size: 48px; margin-bottom: 15px; }
        .status { text-align: center; padding: 15px; margin-bottom: 20px; border-radius: 10px; background: #e0f2fe; color: #0369a1; font-weight: 600; display: none; }
        .status.active { display: block; }
        .eyedropper-hint { background: #fef3c7; color: #92400e; padding: 12px 20px; border-radius: 10px; text-align: center; margin-bottom: 15px; display: none; font-weight: 500; }
        .crop-hint { background: #dbeafe; color: #1e40af; padding: 12px 20px; border-radius: 10px; text-align: center; margin-bottom: 15px; display: none; font-weight: 500; }
        .eyedropper-hint.active, .crop-hint.active { display: block; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .color-preview-tooltip { position: fixed; padding: 8px 12px; background: rgba(0, 0, 0, 0.9); color: white; border-radius: 8px; font-family: monospace; font-size: 14px; pointer-events: none; z-index: 10000; display: none; white-space: nowrap; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 2px solid white; }
        .color-preview-tooltip .color-sample { width: 20px; height: 20px; display: inline-block; vertical-align: middle; margin-right: 8px; border: 1px solid white; border-radius: 4px; }
        .image-assignment { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 20px 0; }
        .assignment-box { border: 2px solid #ddd; border-radius: 10px; padding: 15px; background: #f9fafb; }
        .assignment-box h4 { margin-bottom: 10px; color: #191e31; font-size: 14px; }
        .image-preview-small { width: 100%; height: 100px; object-fit: cover; border-radius: 8px; margin-bottom: 10px; }
        .assignment-select { width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 6px; background: white; }
        @media (max-width: 768px) {
            .upload-section { grid-template-columns: 1fr; }
            .filename-inputs { grid-template-columns: 1fr; }
            h1 { font-size: 1.8em; }
            .subtitle { font-size: 1em; }
            .container { padding: 20px; }
            .upload-box { padding: 30px 15px; }
            .icon { font-size: 36px; }
            .controls, .edit-controls { flex-direction: column; gap: 15px; }
            .control-group, .color-picker-group { width: 100%; }
            .color-picker-row { width: 100%; }
            .color-input { flex: 1; }
            select, input[type="text"] { width: 100% !important; }
            .download-btn { width: 100%; padding: 12px 20px; margin: 5px 0; }
            .button-group { display: flex; flex-direction: column; }
            .info { font-size: 13px; }
            .filename-section { padding: 20px; }
            .image-assignment { grid-template-columns: 1fr; }
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; border-radius: 15px; }
            h1 { font-size: 1.5em; margin-bottom: 8px; }
            .subtitle { font-size: 0.9em; margin-bottom: 20px; }
            .upload-section { gap: 15px; margin-bottom: 25px; }
            .upload-box { padding: 25px 10px; }
            .upload-box h3 { font-size: 1em; }
            .upload-box p { font-size: 12px; }
            .canvas-container { padding: 10px; }
            .status { padding: 10px; font-size: 13px; }
            .color-picker-row { flex-wrap: wrap; }
            .eyedropper-btn { width: 100%; justify-content: center; }
            .filename-section { padding: 15px; }
            .filename-section h3 { font-size: 16px; }
            .filename-preview-text { font-size: 14px; }
            .edit-btn { width: 100%; padding: 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://vituchoa.github.io/moldura/src/logo_beframe.png" style="width: 25%; height: auto; display: block; margin: 0 auto 30px auto;">
        
        <div class="portal-selection">
            <label for="portalSelect">Selecione o Portal:</label>
            <select id="portalSelect" onchange="updatePortalSelection()">
                <option value="">-- Selecione um portal --</option>
                <option value="portal1">Manual da Web</option>
                <option value="portal2">Portal 2</option>
                <option value="portal3">Portal 3</option>
                <option value="custom">Moldura Personalizada</option>
            </select>
        </div>

        <!-- Controle de quantidade de molduras (s√≥ aparece para vertical) -->
        <div class="frame-quantity" id="frameQuantity">
            <label>Quantidade de Molduras na Imagem:</label>
            <div class="quantity-buttons">
                <button class="quantity-btn active" onclick="setFrameQuantity(1)">1 Moldura</button>
                <button class="quantity-btn" onclick="setFrameQuantity(2)">2 Molduras</button>
                <button class="quantity-btn" onclick="setFrameQuantity(3)">3 Molduras</button>
                <button class="quantity-btn" onclick="setFrameQuantity(4)">4 Molduras</button>
            </div>
        </div>

        <div class="upload-section single-column" id="uploadSection">
            <!-- Caixas de upload din√¢micas ser√£o geradas aqui -->
        </div>

        <!-- √Årea para atribuir imagens √†s molduras -->
        <div class="image-assignment" id="imageAssignment" style="display: none;">
            <!-- As caixas de atribui√ß√£o ser√£o geradas dinamicamente -->
        </div>

        <div class="status" id="status">Analisando moldura e enquadrando automaticamente...</div>

        <div class="preview-section" id="previewSection">
            <div class="edit-controls">
                <button class="edit-btn" id="moveBtn" onclick="activateMoveMode()">‚úã Mover Imagem</button>
                <button class="edit-btn" id="cropBtn" onclick="activateCropMode()">‚úÇÔ∏è Cortar Imagem</button>
                <button class="edit-btn" id="resetCropBtn" onclick="resetCrop()" style="display: none;">‚Ü©Ô∏è Redefinir Crop</button>
            </div>

            <div class="crop-hint" id="cropHint">‚úÇÔ∏è Arraste para selecionar a √°rea de corte | Pressione <strong>ESC</strong> para cancelar</div>

            <div class="controls">
                <div class="control-group">
                    <label>Modo de Ajuste</label>
                    <select id="fitMode" onchange="autoFrame()">
                        <option value="cover">Cobrir (sem bordas brancas)</option>
                        <option value="contain">Conter (imagem completa)</option>
                        <option value="fill">Preencher (esticar)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Cor de Fundo</label>
                    <select id="bgMode" onchange="updateColorPickerVisibility()">
                        <option value="dominant">Autom√°tico (cor dominante)</option>
                        <option value="white">Branco</option>
                        <option value="black">Preto</option>
                        <option value="custom">Personalizado</option>
                    </select>
                </div>
                <div class="color-picker-group" id="customColorGroup" style="display: none;">
                    <label>Selecionar Cor</label>
                    <div class="color-picker-row">
                        <div class="color-display" id="colorDisplay" onclick="document.getElementById('colorInput').focus()"></div>
                        <input type="text" id="colorInput" class="color-input" placeholder="#FFFFFF" maxlength="7" value="#FFFFFF">
                        <button type="button" class="eyedropper-btn" id="eyedropperBtn" onclick="activateEyedropper()"><span>üé®</span> Conta-gotas</button>
                    </div>
                </div>
            </div>

            <div class="eyedropper-hint" id="eyedropperHint">üéØ Clique na imagem abaixo para capturar uma cor | Pressione <strong>ESC</strong> para cancelar</div>

            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-wrapper">
                    <canvas id="canvas"></canvas>
                    <div class="crop-overlay" id="cropOverlay"></div>
                </div>
            </div>
            
            <div class="filename-section">
                <h3>üìù Nomenclatura do Arquivo</h3>
                <div class="filename-inputs">
                    <div class="filename-group">
                        <label>Nome do Artigo</label>
                        <input type="text" id="filePrefix" placeholder="ex: artigo" oninput="updateFilenamePreview()">
                    </div>
                    <div class="filename-group">
                        <label>Nome do Arquivo</label>
                        <input type="text" id="articleName" placeholder="ex: titulo-do-meu-artigo" oninput="updateFilenamePreview()">
                    </div>
                </div>
                <div class="filename-preview">
                    <label>üìÑ Nome final do arquivo:</label>
                    <div class="filename-preview-text" id="filenamePreview"><span class="placeholder">Digite o nome do artigo</span></div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="download-btn" onclick="downloadImage()">‚¨áÔ∏è Baixar Imagem</button>
                <button class="download-btn new-btn" onclick="resetAll()">üîÑ Gerar Nova Imagem</button>
            </div>
        </div>

        <div class="info">
            <strong>Como funciona:</strong><br>
            1. Selecione o portal desejado (o sistema detectar√° automaticamente a orienta√ß√£o da imagem)<br>
            2. Para molduras verticais, escolha a quantidade de molduras desejada (1 a 4)<br>
            3. Fa√ßa upload das imagens (pode fazer upload de v√°rias imagens ao mesmo tempo)<br>
            4. Atribua cada imagem a uma moldura espec√≠fica<br>
            5. Para moldura personalizada, selecione a op√ß√£o correspondente e fa√ßa upload da moldura PNG<br>
            6. Use os controles para mover ou cortar as imagens conforme necess√°rio<br>
            7. Configure o nome do arquivo com prefixo e nome do artigo<br>
            8. Baixe o resultado final em alta resolu√ß√£o
            <br><br><strong>Beframe by Beside Media - 2026</strong>
        </div>
    </div>

    <div class="color-preview-tooltip" id="colorPreviewTooltip">
        <span class="color-sample" id="tooltipColorSample"></span>
        <span id="tooltipColorHex">#000000</span>
    </div>

    <script>
        let uploadedImage = null, originalImage = null, frameImage = null, transparentArea = null;
        let uploadedImages = []; // Array para m√∫ltiplas imagens
        let frameImages = []; // Array para m√∫ltiplas molduras (para vertical)
        let dominantColor = '#FFFFFF', customColor = '#FFFFFF';
        let isEyedropperActive = false, isMoveModeActive = false, isCropModeActive = false;
        let selectedPortal = '', isCustomFrame = false, isVerticalFrame = false;
        let frameQuantity = 1; // Quantidade de molduras (1-4)
        let imageAssignments = {}; // Mapeia qual imagem vai em qual moldura
        
        const portalFrames = {
            portal1: { horizontal: 'https://vituchoa.github.io/moldura/src/manualH.png', vertical: 'https://vituchoa.github.io/moldura/src/manualV.png' },
            portal2: { horizontal: 'URL_DA_MOLDURA_HORIZONTAL_PORTAL2.png', vertical: 'URL_DA_MOLDURA_VERTICAL_PORTAL2.png' },
            portal3: { horizontal: 'URL_DA_MOLDURA_HORIZONTAL_PORTAL3.png', vertical: 'URL_DA_MOLDURA_VERTICAL_PORTAL3.png' }
        };
        
        let imageOffset = { x: 0, y: 0 }, isDragging = false, dragStart = { x: 0, y: 0 }, currentDragOffset = { x: 0, y: 0 };
        let cropSelection = null, isDrawingCrop = false, cropStart = { x: 0, y: 0 }, currentCrop = null;
        let currentDrawInfo = { x: 0, y: 0, width: 0, height: 0, scale: 1 };

        document.getElementById('colorInput').value = customColor;
        document.getElementById('colorDisplay').style.backgroundColor = customColor;

        function updatePortalSelection() {
            const portalSelect = document.getElementById('portalSelect');
            selectedPortal = portalSelect.value;
            const uploadSection = document.getElementById('uploadSection');
            const frameQuantityDiv = document.getElementById('frameQuantity');
            const imageAssignmentDiv = document.getElementById('imageAssignment');
            
            // Resetar vari√°veis
            uploadedImages = [];
            frameImages = [];
            imageAssignments = {};
            
            if (selectedPortal === 'custom') {
                isCustomFrame = true;
                isVerticalFrame = false;
                frameQuantityDiv.classList.remove('active');
                imageAssignmentDiv.style.display = 'none';
                createUploadBoxes(1, true); // Apenas 1 caixa para moldura personalizada
            } else if (selectedPortal === '') {
                isCustomFrame = false;
                isVerticalFrame = false;
                frameQuantityDiv.classList.remove('active');
                imageAssignmentDiv.style.display = 'none';
                createUploadBoxes(1, false); // Apenas 1 caixa para imagem
            } else {
                isCustomFrame = false;
                // Para portais predefinidos, vamos detectar a orienta√ß√£o depois que a imagem for carregada
                frameQuantityDiv.classList.remove('active');
                imageAssignmentDiv.style.display = 'none';
                createUploadBoxes(1, false); // Inicialmente 1 caixa
            }
        }
        
        function createUploadBoxes(count, isFrameBox) {
            const uploadSection = document.getElementById('uploadSection');
            uploadSection.innerHTML = '';
            
            if (isFrameBox) {
                // Para moldura personalizada
                uploadSection.classList.remove('single-column');
                uploadSection.classList.remove('multiple-frames');
                
                const box = document.createElement('div');
                box.className = 'upload-box';
                box.id = 'frameBox';
                box.innerHTML = `
                    <div class="icon">üñºÔ∏è</div>
                    <h3 id="frameLabel">Moldura PNG</h3>
                    <p>Clique ou arraste a moldura aqui<br>(PNG com transpar√™ncia)</p>
                    <input type="file" id="frameUpload" accept="image/png" multiple="${count > 1}">
                `;
                uploadSection.appendChild(box);
                setupDragAndDrop(box, box.querySelector('input'), true);
                
                // Configurar evento de change para m√∫ltiplos arquivos
                const input = box.querySelector('input');
                input.addEventListener('change', function(e) {
                    handleFrameUpload(e, 0);
                });
            } else {
                // Para imagens
                if (count === 1) {
                    uploadSection.classList.add('single-column');
                    uploadSection.classList.remove('multiple-frames');
                } else {
                    uploadSection.classList.remove('single-column');
                    uploadSection.classList.add('multiple-frames');
                }
                
                for (let i = 0; i < count; i++) {
                    const box = document.createElement('div');
                    box.className = 'upload-box';
                    box.id = `imageBox${i}`;
                    box.innerHTML = `
                        <div class="icon">üì∑</div>
                        <h3 id="imageLabel${i}">${count === 1 ? 'Sua Imagem' : `Imagem ${i + 1}`}</h3>
                        <p>Clique ou arraste a imagem aqui</p>
                        <input type="file" id="imageUpload${i}" accept="image/*" multiple="${count > 1}">
                    `;
                    uploadSection.appendChild(box);
                    setupDragAndDrop(box, box.querySelector('input'), false);
                    
                    // Configurar evento de change para m√∫ltiplos arquivos
                    const input = box.querySelector('input');
                    input.addEventListener('change', function(e) {
                        handleImageUpload(e, i);
                    });
                }
            }
        }
        
        function setFrameQuantity(quantity) {
            frameQuantity = quantity;
            
            // Atualizar bot√µes ativos
            document.querySelectorAll('.quantity-btn').forEach((btn, index) => {
                if (index + 1 === quantity) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Criar caixas de upload para m√∫ltiplas imagens
            createUploadBoxes(quantity, false);
            
            // Criar interface para atribui√ß√£o de imagens
            createImageAssignmentInterface();
        }
        
        function createImageAssignmentInterface() {
            const imageAssignmentDiv = document.getElementById('imageAssignment');
            imageAssignmentDiv.innerHTML = '';
            imageAssignmentDiv.style.display = 'grid';
            
            for (let i = 0; i < frameQuantity; i++) {
                const box = document.createElement('div');
                box.className = 'assignment-box';
                box.innerHTML = `
                    <h4>Moldura ${i + 1}</h4>
                    <img src="" class="image-preview-small" id="preview${i}" style="display: none;">
                    <select class="assignment-select" id="assign${i}" onchange="updateImageAssignment(${i})">
                        <option value="-1">Selecione uma imagem</option>
                    </select>
                `;
                imageAssignmentDiv.appendChild(box);
            }
            
            updateAssignmentDropdowns();
        }
        
        function updateAssignmentDropdowns() {
            for (let i = 0; i < frameQuantity; i++) {
                const select = document.getElementById(`assign${i}`);
                select.innerHTML = '<option value="-1">Selecione uma imagem</option>';
                
                uploadedImages.forEach((img, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Imagem ${index + 1}`;
                    if (imageAssignments[i] === index) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
                
                // Atualizar pr√©-visualiza√ß√£o
                const assignedIndex = imageAssignments[i];
                const preview = document.getElementById(`preview${i}`);
                if (assignedIndex !== undefined && assignedIndex !== -1 && uploadedImages[assignedIndex]) {
                    preview.src = uploadedImages[assignedIndex].src;
                    preview.style.display = 'block';
                } else {
                    preview.style.display = 'none';
                }
            }
        }
        
        function updateImageAssignment(frameIndex) {
            const select = document.getElementById(`assign${frameIndex}`);
            const imageIndex = parseInt(select.value);
            imageAssignments[frameIndex] = imageIndex;
            
            // Atualizar pr√©-visualiza√ß√£o
            const preview = document.getElementById(`preview${frameIndex}`);
            if (imageIndex !== -1 && uploadedImages[imageIndex]) {
                preview.src = uploadedImages[imageIndex].src;
                preview.style.display = 'block';
            } else {
                preview.style.display = 'none';
            }
            
            // Se temos imagens e molduras, atualizar a visualiza√ß√£o
            if (frameImages.length > 0 && uploadedImages.length > 0) {
                autoFrame();
            }
        }
        
        function detectImageOrientation(img) {
            const imgWidth = img.naturalWidth || img.width;
            const imgHeight = img.naturalHeight || img.height;
            console.log(`Detectando orienta√ß√£o: ${imgWidth} x ${imgHeight}`);
            
            // CORRE√á√ÉO: Agora est√° correto - imagens horizontais s√£o mais largas que altas
            const isHorizontal = imgWidth > imgHeight;
            console.log(`Imagem detectada como: ${isHorizontal ? 'Horizontal' : 'Vertical'}`);
            
            return isHorizontal;
        }
        
        function autoSelectFrame() {
            if (!uploadedImages[0] || !selectedPortal || selectedPortal === 'custom' || selectedPortal === '') {
                console.log('Condi√ß√µes n√£o atendidas para autoSelectFrame');
                return;
            }
            
            const isHorizontal = detectImageOrientation(uploadedImages[0]);
            console.log(`Imagem detectada como: ${isHorizontal ? 'Horizontal' : 'Vertical'}`);
            
            // Atualizar interface baseada na orienta√ß√£o
            const frameQuantityDiv = document.getElementById('frameQuantity');
            if (isHorizontal) {
                // Moldura horizontal - quantidade fixa 1
                isVerticalFrame = false;
                frameQuantityDiv.classList.remove('active');
                imageAssignments = { 0: 0 }; // Apenas uma moldura
                createUploadBoxes(1, false);
            } else {
                // Moldura vertical - mostrar op√ß√µes de quantidade
                isVerticalFrame = true;
                frameQuantityDiv.classList.add('active');
                // Por padr√£o, usar 1 moldura
                frameQuantity = 1;
                setFrameQuantity(1);
            }
            
            // Carregar moldura apropriada
            const frameUrl = isHorizontal ? portalFrames[selectedPortal].horizontal : portalFrames[selectedPortal].vertical;
            console.log(`Carregando moldura: ${frameUrl}`);
            
            loadFrameFromUrl(frameUrl, isHorizontal);
        }
        
        function loadFrameFromUrl(url, isHorizontal = true) {
            document.getElementById('status').classList.add('active');
            document.getElementById('status').textContent = 'Carregando moldura automaticamente...';
            
            frameImages = []; // Resetar array de molduras
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function() {
                if (isHorizontal || frameQuantity === 1) {
                    // Para horizontal ou vertical com 1 moldura
                    frameImages = [img];
                } else {
                    // Para vertical com m√∫ltiplas molduras, carregar a mesma moldura m√∫ltiplas vezes
                    for (let i = 0; i < frameQuantity; i++) {
                        frameImages.push(img);
                    }
                }
                
                document.getElementById('status').textContent = 'Analisando moldura(s) e enquadrando automaticamente...';
                setTimeout(() => {
                    detectTransparentArea();
                    if (uploadedImages.length > 0) autoFrame();
                    document.getElementById('status').classList.remove('active');
                }, 500);
            };
            img.onerror = function() {
                console.error('Erro ao carregar moldura:', url);
                document.getElementById('status').textContent = 'Erro ao carregar moldura. Verifique as URLs no c√≥digo.';
                setTimeout(() => document.getElementById('status').classList.remove('active'), 3000);
            };
            img.src = url;
        }
        
        function handleImageUpload(e, boxIndex) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            // Limpar array de imagens se estamos em modo de √∫nica imagem
            if (frameQuantity === 1 && !isVerticalFrame) {
                uploadedImages = [];
            }
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        const index = uploadedImages.length;
                        uploadedImages.push(img);
                        
                        // Atualizar interface
                        if (frameQuantity === 1 && !isVerticalFrame) {
                            // Modo simples: uma imagem
                            document.getElementById(`imageBox${boxIndex}`).classList.add('has-file');
                            document.getElementById(`imageLabel${boxIndex}`).textContent = '‚úì Imagem Carregada';
                            imageOffset = { x: 0, y: 0 };
                            currentCrop = null;
                            
                            // Salvar como original se for a primeira
                            if (index === 0) {
                                originalImage = new Image();
                                originalImage.src = img.src;
                            }
                            
                            extractDominantColor(img);
                            if (selectedPortal && selectedPortal !== 'custom' && selectedPortal !== '') {
                                autoSelectFrame();
                            } else if (frameImages.length > 0) {
                                autoFrame();
                            }
                        } else {
                            // Modo m√∫ltiplas imagens
                            document.getElementById(`imageBox${boxIndex}`).classList.add('has-file');
                            document.getElementById(`imageLabel${boxIndex}`).textContent = `‚úì ${files.length > 1 ? files.length : ''} Imagem(ns) Carregada(s)`;
                            
                            // Atualizar dropdowns de atribui√ß√£o
                            updateAssignmentDropdowns();
                            
                            // Se j√° temos molduras carregadas, processar
                            if (frameImages.length > 0) {
                                // Atribuir automaticamente se n√£o estiver atribu√≠do
                                for (let j = 0; j < frameQuantity; j++) {
                                    if (imageAssignments[j] === undefined && j < uploadedImages.length) {
                                        imageAssignments[j] = j;
                                    }
                                }
                                updateAssignmentDropdowns();
                                autoFrame();
                            }
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function handleFrameUpload(e, boxIndex) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            frameImages = []; // Resetar array de molduras
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        frameImages.push(img);
                        
                        // Atualizar interface
                        document.getElementById('frameBox').classList.add('has-file');
                        document.getElementById('frameLabel').textContent = `‚úì ${files.length > 1 ? files.length : ''} Moldura(s) Carregada(s)`;
                        document.getElementById('status').classList.add('active');
                        
                        if (i === files.length - 1) {
                            setTimeout(() => {
                                detectTransparentArea();
                                if (uploadedImages.length > 0) autoFrame();
                                document.getElementById('status').classList.remove('active');
                            }, 500);
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function detectTransparentArea() {
            if (frameImages.length === 0) return;
            
            transparentArea = [];
            
            frameImages.forEach((frameImg, index) => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = frameImg.naturalWidth;
                tempCanvas.height = frameImg.naturalHeight;
                tempCtx.drawImage(frameImg, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
                for (let y = 0; y < tempCanvas.height; y++) {
                    for (let x = 0; x < tempCanvas.width; x++) {
                        const idx = (y * tempCanvas.width + x) * 4;
                        const alpha = data[idx + 3];
                        if (alpha < 180) {
                            if (x < minX) minX = x;
                            if (x > maxX) maxX = x;
                            if (y < minY) minY = y;
                            if (y > maxY) maxY = y;
                        }
                    }
                }
                const margin = 3;
                transparentArea[index] = {
                    x: Math.max(0, minX - margin),
                    y: Math.max(0, minY - margin),
                    width: Math.min(tempCanvas.width, maxX - minX + (margin * 2)),
                    height: Math.min(tempCanvas.height, maxY - minY + (margin * 2))
                };
            });
        }
        
        function autoFrame() {
            if (uploadedImages.length === 0 || frameImages.length === 0 || transparentArea.length === 0) return;
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calcular dimens√µes totais do canvas
            let totalWidth = 0, totalHeight = 0, maxHeight = 0;
            
            if (isVerticalFrame && frameQuantity > 1) {
                // Para m√∫ltiplas molduras verticais, dispor horizontalmente
                frameImages.forEach((frame, index) => {
                    totalWidth += frame.naturalWidth;
                    maxHeight = Math.max(maxHeight, frame.naturalHeight);
                });
                totalHeight = maxHeight;
            } else {
                // Para molduras √∫nicas
                totalWidth = frameImages[0].naturalWidth;
                totalHeight = frameImages[0].naturalHeight;
            }
            
            canvas.width = totalWidth;
            canvas.height = totalHeight;
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            const bgMode = document.getElementById('bgMode').value;
            let bgColor = '#FFFFFF';
            if (bgMode === 'dominant' && uploadedImages[0]) bgColor = dominantColor;
            else if (bgMode === 'black') bgColor = '#000000';
            else if (bgMode === 'white') bgColor = '#FFFFFF';
            else if (bgMode === 'custom') bgColor = customColor;
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const fitMode = document.getElementById('fitMode').value;
            let currentX = 0;
            
            for (let i = 0; i < Math.min(frameImages.length, frameQuantity); i++) {
                const frameImg = frameImages[i];
                const area = transparentArea[i];
                
                // Determinar qual imagem usar para esta moldura
                const imageIndex = imageAssignments[i];
                const imageToUse = (imageIndex !== undefined && imageIndex !== -1 && uploadedImages[imageIndex]) ? 
                                  uploadedImages[imageIndex] : uploadedImages[0];
                
                if (!imageToUse) continue;
                
                const targetWidth = area.width, targetHeight = area.height;
                const imgRatio = imageToUse.naturalWidth / imageToUse.naturalHeight;
                const targetRatio = targetWidth / targetHeight;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (fitMode === 'cover') {
                    if (imgRatio > targetRatio) {
                        drawHeight = targetHeight;
                        drawWidth = drawHeight * imgRatio;
                    } else {
                        drawWidth = targetWidth;
                        drawHeight = drawWidth / imgRatio;
                    }
                    drawX = currentX + area.x + (targetWidth - drawWidth) / 2;
                    drawY = area.y + (targetHeight - drawHeight) / 2;
                } else if (fitMode === 'contain') {
                    if (imgRatio > targetRatio) {
                        drawWidth = targetWidth;
                        drawHeight = drawWidth / imgRatio;
                    } else {
                        drawHeight = targetHeight;
                        drawWidth = drawHeight * imgRatio;
                    }
                    drawX = currentX + area.x + (targetWidth - drawWidth) / 2;
                    drawY = area.y + (targetHeight - drawHeight) / 2;
                } else {
                    drawWidth = targetWidth;
                    drawHeight = targetHeight;
                    drawX = currentX + area.x;
                    drawY = area.y;
                }
                
                drawX += imageOffset.x;
                drawY += imageOffset.y;
                
                ctx.drawImage(imageToUse, drawX, drawY, drawWidth, drawHeight);
                ctx.drawImage(frameImg, currentX, 0, frameImg.naturalWidth, frameImg.naturalHeight);
                
                currentX += frameImg.naturalWidth;
            }
            
            document.getElementById('previewSection').classList.add('active');
        }

        // Restante do c√≥digo permanece similar (fun√ß√µes de movimenta√ß√£o, crop, etc.)
        // ... [mantenha as fun√ß√µes restantes como est√£o, apenas ajustando onde referenciam uploadedImage para uploadedImages[0]]

        // As fun√ß√µes extractDominantColor, activateEyedropper, activateMoveMode, activateCropMode, etc.
        // devem ser ajustadas para trabalhar com o array uploadedImages quando necess√°rio

        function extractDominantColor(img) {
            // ... mantida igual
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const size = 50;
            tempCanvas.width = size;
            tempCanvas.height = size;
            tempCtx.drawImage(img, 0, 0, size, size);
            const imageData = tempCtx.getImageData(0, 0, size, size);
            const data = imageData.data;
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < data.length; i += 4) {
                const red = data[i], green = data[i + 1], blue = data[i + 2], alpha = data[i + 3];
                if (alpha > 128) {
                    r += red;
                    g += green;
                    b += blue;
                    count++;
                }
            }
            if (count > 0) {
                r = Math.floor(r / count);
                g = Math.floor(g / count);
                b = Math.floor(b / count);
                dominantColor = rgbToHex(r, g, b);
            }
        }

        // As fun√ß√µes de setupDragAndDrop, updateFilenamePreview, generateFileName, etc.
        // devem ser mantidas conforme o c√≥digo original

        function setupDragAndDrop(boxElement, inputElement, isFrame = false) {
            // ... mantida igual
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                boxElement.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); }, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                boxElement.addEventListener(eventName, () => boxElement.classList.add('drag-over'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                boxElement.addEventListener(eventName, () => boxElement.classList.remove('drag-over'), false);
            });
            boxElement.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (isFrame && !file.type.match('image/png')) {
                        alert('Por favor, selecione um arquivo PNG para a moldura.');
                        return;
                    }
                    if (!isFrame && !file.type.match('image.*')) {
                        alert('Por favor, selecione um arquivo de imagem v√°lido.');
                        return;
                    }
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    inputElement.files = dataTransfer.files;
                    inputElement.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }, false);
            boxElement.addEventListener('click', (e) => {
                if (!boxElement.classList.contains('drag-over')) inputElement.click();
            });
        }

        function updateFilenamePreview() {
            // ... mantida igual
            const prefix = document.getElementById('filePrefix').value.trim();
            const articleName = document.getElementById('articleName').value.trim();
            const preview = document.getElementById('filenamePreview');
            if (!articleName) {
                preview.innerHTML = '<span class="placeholder" style="color: #999;">Digite o nome do artigo</span>';
                return;
            }
            const cleanPrefix = prefix.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            const cleanArticle = articleName.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            let finalName = '';
            if (cleanPrefix && cleanArticle) {
                finalName = `${cleanPrefix}<span class="separator">-</span>${cleanArticle}.png`;
            } else if (cleanArticle) {
                finalName = `${cleanArticle}.png`;
            } else {
                finalName = '<span class="placeholder" style="color: #999;">Digite o nome do artigo</span>';
            }
            preview.innerHTML = finalName;
        }

        function generateFileName() {
            // ... mantida igual
            const prefix = document.getElementById('filePrefix').value.trim();
            const articleName = document.getElementById('articleName').value.trim();
            if (!articleName) return 'imagem-enquadrada';
            const cleanPrefix = prefix.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            const cleanArticle = articleName.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            if (cleanPrefix && cleanArticle) return `${cleanPrefix}-${cleanArticle}`;
            else if (cleanArticle) return cleanArticle;
            else return 'imagem-enquadrada';
        }

        function resetAll() {
            // Resetar todas as vari√°veis
            uploadedImage = null;
            uploadedImages = [];
            originalImage = null;
            frameImage = null;
            frameImages = [];
            transparentArea = null;
            dominantColor = '#FFFFFF';
            customColor = '#FFFFFF';
            imageOffset = { x: 0, y: 0 };
            currentCrop = null;
            selectedPortal = '';
            isCustomFrame = false;
            isVerticalFrame = false;
            frameQuantity = 1;
            imageAssignments = {};
            currentDrawInfo = { x: 0, y: 0, width: 0, height: 0, scale: 1 };
            
            // Resetar interface
            document.getElementById('portalSelect').value = '';
            document.getElementById('colorInput').value = customColor;
            document.getElementById('colorDisplay').style.backgroundColor = customColor;
            document.getElementById('filePrefix').value = '';
            document.getElementById('articleName').value = '';
            updateFilenamePreview();
            document.getElementById('frameQuantity').classList.remove('active');
            document.getElementById('imageAssignment').style.display = 'none';
            document.getElementById('previewSection').classList.remove('active');
            document.getElementById('fitMode').value = 'cover';
            document.getElementById('bgMode').value = 'dominant';
            document.getElementById('customColorGroup').style.display = 'none';
            document.getElementById('resetCropBtn').style.display = 'none';
            
            // Resetar bot√µes de quantidade
            document.querySelectorAll('.quantity-btn').forEach((btn, index) => {
                if (index === 0) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            deactivateEyedropper();
            deactivateMoveMode();
            deactivateCropMode();
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Recriar interface de upload inicial
            createUploadBoxes(1, false);
        }

        // Event listeners e fun√ß√µes auxiliares mantidas
        document.getElementById('colorInput').addEventListener('input', function() {
            let value = this.value;
            if (value.length <= 7) {
                if (value.length > 0 && !value.startsWith('#')) {
                    value = '#' + value;
                    this.value = value;
                }
                this.value = value.toUpperCase();
            }
        });

        document.getElementById('colorInput').addEventListener('blur', function() {
            updateColorFromInput();
        });

        document.getElementById('colorInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') updateColorFromInput();
        });

        document.getElementById('colorDisplay').addEventListener('click', function() {
            document.getElementById('colorInput').focus();
            document.getElementById('colorInput').select();
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (isEyedropperActive) deactivateEyedropper();
                if (isCropModeActive) deactivateCropMode();
            }
        });

        // Inicializar
        updateColorPickerVisibility();
        updateFilenamePreview();
        createUploadBoxes(1, false); // Interface inicial
    </script>
</body>
</html>

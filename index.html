<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beframe by Beside Media</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Funnel+Display:wght@300..800&display=swap');
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Funnel Display', sans-serif;
            background: url('https://vituchoa.github.io/moldura/src/fundo.png') center/cover no-repeat fixed;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .portal-selection {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 15px;
            border: 2px solid #e0e7ff;
        }
        .portal-selection label {
            display: block;
            font-size: 16px;
            font-weight: 600;
            color: #191e31;
            margin-bottom: 10px;
        }
        .portal-selection select {
            width: 100%;
            max-width: 400px;
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 15px;
            font-family: inherit;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        .frame-count-selector {
            margin-top: 15px;
            display: none;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
        }
        .frame-count-selector.active {
            display: block;
        }
        .frame-count-selector label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #191e31;
            margin-bottom: 10px;
        }
        .frame-count-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .frame-count-btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-family: inherit;
        }
        .frame-count-btn:hover {
            border-color: #191e31;
        }
        .frame-count-btn.active {
            background: #191e31;
            color: white;
            border-color: #191e31;
        }
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        .upload-section.single-column {
            grid-template-columns: 1fr;
        }
        .multi-image-uploads {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .multi-image-uploads.active {
            display: grid;
        }
        .upload-box {
            border: 3px dashed #191e31;
            border-radius: 15px;
            padding: 30px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
            position: relative;
        }
        .upload-box:hover {
            border-color: #5568d3;
            background: #f0f2ff;
            transform: translateY(-5px);
        }
        .upload-box.has-file {
            border-color: #10b981;
            background: #f0fdf4;
        }
        .upload-box.has-file h3 {
            color: #10b981;
        }
        .upload-box h3 {
            color: #191e31;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        .upload-box p {
            color: #666;
            font-size: 12px;
        }
        .icon {
            font-size: 32px;
            margin-bottom: 8px;
        }
        input[type="file"] {
            display: none;
        }
        .preview-section {
            display: none;
        }
        .preview-section.active {
            display: block;
        }
        .canvas-container {
            text-align: center;
            margin-bottom: 20px;
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            position: relative;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 80vh;
        }
        .canvas-wrapper {
            display: inline-block;
            position: relative;
        }
        #canvas {
            max-width: 100%;
            height: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: block;
            cursor: move;
            touch-action: none;
        }
        #canvas.eyedropper-mode {
            cursor: crosshair;
        }
        #canvas.crop-mode {
            cursor: crosshair;
        }
        .crop-overlay {
            position: absolute;
            border: 2px dashed #FF0000;
            background: rgba(255, 0, 0, 0.1);
            pointer-events: none;
            display: none;
        }
        .crop-overlay.active {
            display: block;
        }
        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }
        select, button {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            background: white;
            font-family: inherit;
        }
        button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s;
            font-weight: 600;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .color-picker-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .color-picker-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .color-input {
            width: 120px;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: monospace;
            text-transform: uppercase;
            background: white;
        }
        .color-display {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.3s;
        }
        .eyedropper-btn {
            background: #191e31;
            color: white;
            border: none;
        }
        .eyedropper-btn:hover {
            background: #5568d3;
        }
        .eyedropper-btn.active {
            background: #10b981;
        }
        .filename-section {
            background: #f8f9ff;
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }
        .filename-section h3 {
            color: #191e31;
            margin-bottom: 15px;
            font-size: 18px;
            text-align: center;
        }
        .filename-inputs {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        .filename-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .filename-group label {
            font-size: 13px;
            color: #666;
            font-weight: 600;
        }
        .filename-group input {
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            transition: all 0.3s;
        }
        .filename-preview {
            background: white;
            border: 2px solid #10b981;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        .filename-preview-text {
            font-family: monospace;
            font-size: 16px;
            color: #10b981;
            font-weight: bold;
        }
        .download-btn {
            background: #10b981;
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
            display: inline-block;
            margin: 10px;
        }
        .download-btn:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
        }
        .new-btn {
            background: #191e31;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        .new-btn:hover {
            background: #5568d3;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        .edit-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .frame-selector {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #f0f2ff;
            font-weight: 600;
            color: #191e31;
        }
        .edit-btn {
            background: #8b5cf6;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 8px;
        }
        .edit-btn:hover {
            background: #7c3aed;
        }
        .edit-btn.active {
            background: #10b981;
        }
        .button-group {
            text-align: center;
            margin-top: 20px;
        }
        .info {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        .status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 10px;
            background: #e0f2fe;
            color: #0369a1;
            font-weight: 600;
            display: none;
        }
        .status.active {
            display: block;
        }
        .eyedropper-hint, .crop-hint {
            background: #fef3c7;
            color: #92400e;
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            display: none;
            font-weight: 500;
        }
        .crop-hint {
            background: #dbeafe;
            color: #1e40af;
        }
        .eyedropper-hint.active, .crop-hint.active {
            display: block;
        }
        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
            .filename-inputs {
                grid-template-columns: 1fr;
            }
            .multi-image-uploads {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="https://vituchoa.github.io/moldura/src/logo_beframe.png" style="width: 25%; height: auto; display: block; margin: 0 auto 30px auto;">

        <div class="portal-selection">
            <label for="portalSelect">Selecione o Portal:</label>
            <select id="portalSelect" onchange="updatePortalSelection()">
                <option value="" selected>-- Selecione um portal --</option>
                <option value="portal1">Manual da Web</option>
                <option value="portal2">Portal 2</option>
                <option value="portal3">Portal 3</option>
                <option value="custom">Moldura Personalizada</option>
            </select>
            
            <div class="frame-count-selector" id="frameCountSelector">
                <label>Quantidade de Molduras na Imagem Final:</label>
                <div class="frame-count-buttons">
                    <button class="frame-count-btn active" onclick="setFrameCount(1)">1</button>
                    <button class="frame-count-btn" onclick="setFrameCount(2)">2</button>
                    <button class="frame-count-btn" onclick="setFrameCount(3)">3</button>
                    <button class="frame-count-btn" onclick="setFrameCount(4)">4</button>
                </div>
            </div>
        </div>

        <div class="upload-section single-column" id="singleUploadSection" style="display: none;">
            <div class="upload-box" id="imageBox">
                <div class="icon">üì∑</div>
                <h3 id="imageLabel">Sua Imagem</h3>
                <p>Clique ou arraste a imagem aqui</p>
                <input type="file" id="imageUpload" accept="image/*">
            </div>

            <div class="upload-box" id="frameBox" style="display: none;">
                <div class="icon">üñºÔ∏è</div>
                <h3 id="frameLabel">Moldura PNG</h3>
                <p>Clique ou arraste a moldura aqui<br>(PNG com transpar√™ncia)</p>
                <input type="file" id="frameUpload" accept="image/png">
            </div>
        </div>

        <div class="multi-image-uploads" id="multiImageUploads"></div>

        <div class="status" id="status">Processando imagens...</div>

        <div class="preview-section" id="previewSection">
            <div class="edit-controls">
                <div class="frame-selector" id="frameSelector">Editando: Moldura 1</div>
                <button class="edit-btn" id="moveBtn" onclick="activateMoveMode()">‚úã Mover Imagem</button>
                <button class="edit-btn" id="cropBtn" onclick="activateCropMode()">‚úÇÔ∏è Cortar Imagem</button>
                <button class="edit-btn" id="resetCropBtn" onclick="resetCrop()" style="display: none;">‚Ü©Ô∏è Redefinir Crop</button>
            </div>

            <div class="crop-hint" id="cropHint">‚úÇÔ∏è Arraste para selecionar a √°rea de corte | Pressione <strong>ESC</strong> para cancelar</div>

            <div class="controls">
                <div class="control-group">
                    <label>Modo de Ajuste</label>
                    <select id="fitMode" onchange="updateFrameSettings()">
                        <option value="cover">Cobrir (sem bordas brancas)</option>
                        <option value="contain">Conter (imagem completa)</option>
                        <option value="fill">Preencher (esticar)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Cor de Fundo</label>
                    <select id="bgMode" onchange="updateFrameSettings()">
                        <option value="dominant">Autom√°tico (cor dominante)</option>
                        <option value="white">Branco</option>
                        <option value="black">Preto</option>
                        <option value="custom">Personalizado</option>
                    </select>
                </div>
                <div class="color-picker-group" id="customColorGroup" style="display: none;">
                    <label>Selecionar Cor</label>
                    <div class="color-picker-row">
                        <div class="color-display" id="colorDisplay"></div>
                        <input type="text" id="colorInput" class="color-input" placeholder="#FFFFFF" maxlength="7" value="#FFFFFF">
                        <button type="button" class="eyedropper-btn" id="eyedropperBtn" onclick="activateEyedropper()">üé® Conta-gotas</button>
                    </div>
                </div>
            </div>

            <div class="eyedropper-hint" id="eyedropperHint">üéØ Clique na imagem abaixo para capturar uma cor | Pressione <strong>ESC</strong> para cancelar</div>

            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <canvas id="canvas"></canvas>
                    <div class="crop-overlay" id="cropOverlay"></div>
                </div>
            </div>
            
            <div class="filename-section">
                <h3>üìù Nomenclatura do Arquivo</h3>
                <div class="filename-inputs">
                    <div class="filename-group">
                        <label>Nome do Artigo</label>
                        <input type="text" id="filePrefix" placeholder="ex: artigo" oninput="updateFilenamePreview()">
                    </div>
                    <div class="filename-group">
                        <label>Nome do Arquivo</label>
                        <input type="text" id="articleName" placeholder="ex: titulo-do-meu-artigo" oninput="updateFilenamePreview()">
                    </div>
                </div>
                <div class="filename-preview">
                    <label>üìÑ Nome final do arquivo:</label>
                    <div class="filename-preview-text" id="filenamePreview"><span class="placeholder">Digite o nome do artigo</span></div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="download-btn" onclick="downloadImage()">‚¨áÔ∏è Baixar Imagem</button>
                <button class="download-btn new-btn" onclick="resetAll()">üîÑ Gerar Nova Imagem</button>
            </div>
        </div>

        <div class="info">
            <strong>Como funciona:</strong><br>
            1. Selecione o portal desejado<br>
            2. Para molduras verticais, escolha quantas molduras aparecer√£o na imagem final (1 a 4, lado a lado)<br>
            3. Para molduras horizontais, as molduras ser√£o organizadas uma embaixo da outra<br>
            4. Fa√ßa upload das imagens - o sistema detecta automaticamente se √© horizontal ou vertical<br>
            5. Use os controles para ajustar cada moldura individualmente<br>
            6. Baixe a imagem final com todas as molduras combinadas em uma √∫nica imagem
            <br><br><strong>Beframe by Beside Media - 2026</strong>
        </div>
    </div>

    <script>
        let frameCount = 1;
        let frames = [];
        let selectedPortal = '';
        let isCustomFrame = false;
        let customColor = '#FFFFFF';
        let activeFrameIndex = 0;
        let isMoveModeActive = false;
        let isCropModeActive = false;
        let isEyedropperActive = false;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentDragOffset = { x: 0, y: 0 };
        let isDrawingCrop = false;
        let cropStart = { x: 0, y: 0 };
        let cropSelection = null;
        
        const portalFrames = {
            portal1: { 
                horizontal: 'https://vituchoa.github.io/moldura/src/manualV.png', 
                vertical: 'https://vituchoa.github.io/moldura/src/manualH.png' 
            },
            portal2: { 
                horizontal: 'URL_DA_MOLDURA_VERTICAL_PORTAL2.png', 
                vertical: 'URL_DA_MOLDURA_HORIZONTAL_PORTAL2.png' 
            },
            portal3: { 
                horizontal: 'URL_DA_MOLDURA_VERTICAL_PORTAL3.png', 
                vertical: 'URL_DA_MOLDURA_HORIZONTAL_PORTAL3.png' 
            }
        };

        function initializeFrames(count) {
            // Salvar as imagens existentes antes de resetar
            const existingFrames = [...frames];
            frames = [];
            
            for (let i = 0; i < count; i++) {
                // Se j√° existia uma frame nessa posi√ß√£o, manter seus dados
                if (existingFrames[i]) {
                    frames.push({
                        uploadedImage: existingFrames[i].uploadedImage,
                        originalImage: existingFrames[i].originalImage,
                        frameImage: null, // Resetar frameImage - ser√° recarregado se necess√°rio
                        transparentArea: null,
                        dominantColor: existingFrames[i].dominantColor || '#FFFFFF',
                        imageOffset: existingFrames[i].imageOffset || { x: 0, y: 0 },
                        currentCrop: existingFrames[i].currentCrop,
                        isVertical: existingFrames[i].isVertical || false,
                        fitMode: existingFrames[i].fitMode || 'cover',
                        bgMode: existingFrames[i].bgMode || 'dominant',
                        customColor: existingFrames[i].customColor || '#FFFFFF',
                        frameOrientation: existingFrames[i].frameOrientation || 'vertical' // 'vertical' ou 'horizontal'
                    });
                } else {
                    // Nova frame vazia
                    frames.push({
                        uploadedImage: null,
                        originalImage: null,
                        frameImage: null,
                        transparentArea: null,
                        dominantColor: '#FFFFFF',
                        imageOffset: { x: 0, y: 0 },
                        currentCrop: null,
                        isVertical: false,
                        fitMode: 'cover',
                        bgMode: 'dominant',
                        customColor: '#FFFFFF',
                        frameOrientation: 'vertical' // Default
                    });
                }
            }
        }

        function setFrameCount(count) {
            const oldCount = frameCount;
            frameCount = count;
            
            // Atualizar bot√µes ativos
            document.querySelectorAll('.frame-count-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Preservar imagens existentes
            const existingImages = [];
            for (let i = 0; i < Math.min(oldCount, count); i++) {
                existingImages.push({
                    uploadedImage: frames[i]?.uploadedImage,
                    originalImage: frames[i]?.originalImage,
                    dominantColor: frames[i]?.dominantColor || '#FFFFFF',
                    imageOffset: frames[i]?.imageOffset || { x: 0, y: 0 },
                    currentCrop: frames[i]?.currentCrop,
                    isVertical: frames[i]?.isVertical || false,
                    fitMode: frames[i]?.fitMode || 'cover',
                    bgMode: frames[i]?.bgMode || 'dominant',
                    customColor: frames[i]?.customColor || '#FFFFFF',
                    frameOrientation: frames[i]?.frameOrientation || 'vertical'
                });
            }
            
            // Reinicializar frames
            initializeFrames(count);
            
            // Restaurar imagens preservadas
            for (let i = 0; i < Math.min(oldCount, count); i++) {
                if (existingImages[i]?.uploadedImage) {
                    frames[i].uploadedImage = existingImages[i].uploadedImage;
                    frames[i].originalImage = existingImages[i].originalImage;
                    frames[i].dominantColor = existingImages[i].dominantColor;
                    frames[i].imageOffset = existingImages[i].imageOffset;
                    frames[i].currentCrop = existingImages[i].currentCrop;
                    frames[i].isVertical = existingImages[i].isVertical;
                    frames[i].fitMode = existingImages[i].fitMode;
                    frames[i].bgMode = existingImages[i].bgMode;
                    frames[i].customColor = existingImages[i].customColor;
                    frames[i].frameOrientation = existingImages[i].frameOrientation;
                }
            }
            
            // Recriar caixas de upload
            createMultipleUploadBoxes();
            
            // Atualizar status das caixas de upload
            updateUploadBoxesStatus();
            
            // Recarregar molduras para as frames que t√™m imagens
            reloadFramesForExistingImages();
            
            // Se j√° tivermos todas as imagens e molduras, mostrar preview
            checkAllImagesReady();
        }

        function createMultipleUploadBoxes() {
            const container = document.getElementById('multiImageUploads');
            container.innerHTML = '';
            
            for (let i = 0; i < frameCount; i++) {
                const box = document.createElement('div');
                box.className = 'upload-box';
                box.id = `uploadBox${i}`;
                const hasImage = frames[i]?.uploadedImage;
                box.innerHTML = `
                    <div class="icon">${hasImage ? '‚úì' : 'üì∑'}</div>
                    <h3>${hasImage ? `‚úì Moldura ${i + 1}` : `Moldura ${i + 1}`}</h3>
                    <p>${hasImage ? 'Imagem j√° carregada' : 'Clique ou arraste aqui'}</p>
                    <input type="file" id="imageUpload${i}" accept="image/*">
                `;
                if (hasImage) {
                    box.classList.add('has-file');
                }
                box.onclick = () => document.getElementById(`imageUpload${i}`).click();
                
                const input = box.querySelector('input');
                input.addEventListener('change', (e) => handleImageUpload(i, e));
                
                container.appendChild(box);
            }
        }

        function updateUploadBoxesStatus() {
            for (let i = 0; i < frameCount; i++) {
                const box = document.getElementById(`uploadBox${i}`);
                if (box) {
                    const hasImage = frames[i]?.uploadedImage;
                    const icon = box.querySelector('.icon');
                    const title = box.querySelector('h3');
                    const text = box.querySelector('p');
                    
                    if (hasImage) {
                        box.classList.add('has-file');
                        icon.textContent = '‚úì';
                        title.textContent = `‚úì Moldura ${i + 1}`;
                        text.textContent = 'Imagem j√° carregada';
                    } else {
                        box.classList.remove('has-file');
                        icon.textContent = 'üì∑';
                        title.textContent = `Moldura ${i + 1}`;
                        text.textContent = 'Clique ou arraste aqui';
                    }
                }
            }
        }

        function reloadFramesForExistingImages() {
            for (let i = 0; i < frameCount; i++) {
                if (frames[i]?.uploadedImage && selectedPortal && selectedPortal !== '' && selectedPortal !== 'custom') {
                    const isHorizontal = frames[i].isVertical ? false : true;
                    const frameUrl = isHorizontal 
                        ? portalFrames[selectedPortal].horizontal 
                        : portalFrames[selectedPortal].vertical;
                    
                    loadFrameForImage(i, frameUrl);
                }
            }
        }

        function updatePortalSelection() {
            const portalSelect = document.getElementById('portalSelect');
            selectedPortal = portalSelect.value;
            const frameBox = document.getElementById('frameBox');
            const uploadSection = document.getElementById('singleUploadSection');
            const multiUploadSection = document.getElementById('multiImageUploads');
            const frameCountSelector = document.getElementById('frameCountSelector');
            
            // Esconder todas as se√ß√µes de upload inicialmente
            uploadSection.style.display = 'none';
            multiUploadSection.classList.remove('active');
            frameCountSelector.classList.remove('active');
            
            if (selectedPortal === 'custom') {
                frameBox.style.display = 'block';
                uploadSection.classList.remove('single-column');
                uploadSection.style.display = 'grid';
                isCustomFrame = true;
                
                // Resetar apenas a frame atual
                activeFrameIndex = 0;
                
                // N√£o resetar imagens existentes - s√≥ limpar a moldura
                if (frames.length > 0) {
                    frames[0].frameImage = null;
                    frames[0].transparentArea = null;
                } else {
                    initializeFrames(1);
                }
                
                // Atualizar UI
                document.getElementById('frameBox').classList.remove('has-file');
                document.getElementById('frameLabel').textContent = 'Moldura PNG';
                document.getElementById('previewSection').classList.remove('active');
                
            } else if (selectedPortal === '') {
                // Quando "Selecione um portal" estiver selecionado, esconder tudo
                frameBox.style.display = 'none';
                uploadSection.style.display = 'none';
                multiUploadSection.classList.remove('active');
                frameCountSelector.classList.remove('active');
                isCustomFrame = false;
                
                // Esconder preview
                document.getElementById('previewSection').classList.remove('active');
                
            } else {
                // Portal normal selecionado
                frameBox.style.display = 'none';
                frameCountSelector.classList.add('active');
                multiUploadSection.classList.add('active');
                isCustomFrame = false;
                
                // Criar caixas de upload m√∫ltiplas
                createMultipleUploadBoxes();
                
                // Recarregar molduras para imagens existentes
                reloadFramesForExistingImages();
            }
        }

        function detectImageOrientation(img) {
            const imgWidth = img.naturalWidth || img.width;
            const imgHeight = img.naturalHeight || img.height;
            return imgWidth > imgHeight; // true = horizontal, false = vertical
        }

        function handleImageUpload(index, event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    frames[index].uploadedImage = img;
                    frames[index].originalImage = new Image();
                    frames[index].originalImage.src = img.src;
                    frames[index].imageOffset = { x: 0, y: 0 };
                    frames[index].currentCrop = null; // Resetar crop ao fazer novo upload
                    
                    extractDominantColor(img, index);
                    
                    const isHorizontal = detectImageOrientation(img);
                    frames[index].isVertical = !isHorizontal;
                    
                    if (selectedPortal === 'custom') {
                        // Para moldura personalizada
                        document.getElementById(`uploadBox${index}`).classList.add('has-file');
                        document.getElementById(`uploadBox${index}`).querySelector('h3').textContent = `‚úì Imagem ${index + 1}`;
                        document.getElementById(`uploadBox${index}`).querySelector('p').textContent = 'Imagem carregada';
                        
                        // Mostrar bot√£o resetCropBtn se necess√°rio
                        if (frames[index].originalImage) {
                            document.getElementById('resetCropBtn').style.display = 'inline-flex';
                        }
                        
                        // Verificar se j√° temos a moldura
                        if (frames[index].frameImage) {
                            checkAllImagesReady();
                        }
                    } else if (selectedPortal && selectedPortal !== '') {
                        const frameUrl = isHorizontal 
                            ? portalFrames[selectedPortal].horizontal 
                            : portalFrames[selectedPortal].vertical;
                        
                        loadFrameForImage(index, frameUrl);
                        
                        // Atualizar UI da caixa de upload
                        document.getElementById(`uploadBox${index}`).classList.add('has-file');
                        document.getElementById(`uploadBox${index}`).querySelector('.icon').textContent = '‚úì';
                        document.getElementById(`uploadBox${index}`).querySelector('h3').textContent = `‚úì Moldura ${index + 1}`;
                        document.getElementById(`uploadBox${index}`).querySelector('p').textContent = 'Imagem carregada';
                        
                        // Mostrar bot√£o resetCropBtn se necess√°rio
                        if (frames[index].originalImage) {
                            document.getElementById('resetCropBtn').style.display = 'inline-flex';
                        }
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function loadFrameForImage(index, url) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function() {
                frames[index].frameImage = img;
                // Determinar orienta√ß√£o da moldura
                const isFrameHorizontal = img.naturalWidth > img.naturalHeight;
                frames[index].frameOrientation = isFrameHorizontal ? 'horizontal' : 'vertical';
                detectTransparentArea(index);
                checkAllImagesReady();
            };
            img.onerror = function() {
                console.error('Erro ao carregar moldura:', url);
                alert('Erro ao carregar a moldura. Verifique a URL da moldura.');
            };
            img.src = url;
        }

        function detectTransparentArea(index) {
            const frameImage = frames[index].frameImage;
            if (!frameImage) return;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = frameImage.naturalWidth || frameImage.width;
            tempCanvas.height = frameImage.naturalHeight || frameImage.height;
            tempCtx.drawImage(frameImage, 0, 0);
            
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
            
            for (let y = 0; y < tempCanvas.height; y++) {
                for (let x = 0; x < tempCanvas.width; x++) {
                    const idx = (y * tempCanvas.width + x) * 4;
                    const alpha = data[idx + 3];
                    if (alpha < 180) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            
            const margin = 3;
            frames[index].transparentArea = {
                x: Math.max(0, minX - margin),
                y: Math.max(0, minY - margin),
                width: Math.min(tempCanvas.width, maxX - minX + (margin * 2)),
                height: Math.min(tempCanvas.height, maxY - minY + (margin * 2))
            };
        }

        function extractDominantColor(img, index) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const size = 50;
            tempCanvas.width = size;
            tempCanvas.height = size;
            tempCtx.drawImage(img, 0, 0, size, size);
            
            const imageData = tempCtx.getImageData(0, 0, size, size);
            const data = imageData.data;
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const alpha = data[i + 3];
                if (alpha > 128) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    count++;
                }
            }
            
            if (count > 0) {
                r = Math.floor(r / count);
                g = Math.floor(g / count);
                b = Math.floor(b / count);
                frames[index].dominantColor = rgbToHex(r, g, b);
            }
        }

        function rgbToHex(r, g, b) {
            return "#" + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }

        function checkAllImagesReady() {
            let allReady = true;
            for (let i = 0; i < frameCount; i++) {
                if (!frames[i].uploadedImage || !frames[i].frameImage) {
                    allReady = false;
                    break;
                }
            }
            
            if (allReady) {
                // Garantir que todas as √°reas transparentes sejam detectadas
                for (let i = 0; i < frameCount; i++) {
                    if (frames[i].frameImage && !frames[i].transparentArea) {
                        detectTransparentArea(i);
                    }
                }
                
                renderFinalCanvas();
                document.getElementById('previewSection').classList.add('active');
                updateFrameSelector();
                loadFrameSettings();
            }
        }

        function updateFrameSelector() {
            const selector = document.getElementById('frameSelector');
            if (frameCount > 1) {
                selector.textContent = `Editando: Moldura ${activeFrameIndex + 1}`;
                selector.style.display = 'block';
                selector.onclick = () => {
                    activeFrameIndex = (activeFrameIndex + 1) % frameCount;
                    updateFrameSelector();
                    loadFrameSettings();
                    renderFinalCanvas();
                };
            } else {
                selector.style.display = 'none';
            }
        }

        function loadFrameSettings() {
            if (frames[activeFrameIndex]) {
                const frame = frames[activeFrameIndex];
                
                document.getElementById('fitMode').value = frame.fitMode || 'cover';
                document.getElementById('bgMode').value = frame.bgMode || 'dominant';
                
                customColor = frame.customColor || '#FFFFFF';
                document.getElementById('colorInput').value = customColor;
                document.getElementById('colorDisplay').style.backgroundColor = customColor;
                
                updateColorPickerVisibility();
                
                // Mostrar/esconder bot√£o resetCropBtn
                if (frame.currentCrop || frame.originalImage) {
                    document.getElementById('resetCropBtn').style.display = 'inline-flex';
                } else {
                    document.getElementById('resetCropBtn').style.display = 'none';
                }
            }
        }

        function updateFrameSettings() {
            if (frames[activeFrameIndex]) {
                frames[activeFrameIndex].fitMode = document.getElementById('fitMode').value;
                frames[activeFrameIndex].bgMode = document.getElementById('bgMode').value;
                frames[activeFrameIndex].customColor = customColor;
                
                updateColorPickerVisibility();
                renderFinalCanvas();
            }
        }

        function renderFinalCanvas() {
            if (frames.length === 0) return;
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Determinar layout baseado na orienta√ß√£o da primeira moldura
            const firstFrameOrientation = frames[0].frameOrientation || 'vertical';
            let canvasWidth = 0;
            let canvasHeight = 0;
            let hasValidFrames = false;
            
            if (firstFrameOrientation === 'vertical') {
                // Layout horizontal para molduras verticais (lado a lado)
                for (let i = 0; i < frameCount; i++) {
                    if (frames[i].frameImage) {
                        const frameWidth = frames[i].frameImage.naturalWidth || frames[i].frameImage.width;
                        const frameHeight = frames[i].frameImage.naturalHeight || frames[i].frameImage.height;
                        canvasWidth += frameWidth;
                        canvasHeight = Math.max(canvasHeight, frameHeight);
                        hasValidFrames = true;
                    }
                }
            } else {
                // Layout vertical para molduras horizontais (uma embaixo da outra)
                for (let i = 0; i < frameCount; i++) {
                    if (frames[i].frameImage) {
                        const frameWidth = frames[i].frameImage.naturalWidth || frames[i].frameImage.width;
                        const frameHeight = frames[i].frameImage.naturalHeight || frames[i].frameImage.height;
                        canvasWidth = Math.max(canvasWidth, frameWidth);
                        canvasHeight += frameHeight;
                        hasValidFrames = true;
                    }
                }
            }
            
            if (!hasValidFrames) return;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (firstFrameOrientation === 'vertical') {
                // Renderizar molduras verticais lado a lado
                let currentX = 0;
                for (let i = 0; i < frameCount; i++) {
                    const frame = frames[i];
                    if (!frame.frameImage) {
                        continue;
                    }
                    
                    const frameWidth = frame.frameImage.naturalWidth || frame.frameImage.width;
                    const frameHeight = frame.frameImage.naturalHeight || frame.frameImage.height;
                    
                    const bgMode = frame.bgMode || 'dominant';
                    let bgColor = '#FFFFFF';
                    if (bgMode === 'dominant') bgColor = frame.dominantColor || '#FFFFFF';
                    else if (bgMode === 'black') bgColor = '#000000';
                    else if (bgMode === 'white') bgColor = '#FFFFFF';
                    else if (bgMode === 'custom') bgColor = frame.customColor || '#FFFFFF';
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(currentX, 0, frameWidth, frameHeight);
                    
                    if (frame.uploadedImage && frame.transparentArea) {
                        const fitMode = frame.fitMode || 'cover';
                        const targetWidth = frame.transparentArea.width;
                        const targetHeight = frame.transparentArea.height;
                        const imgRatio = frame.uploadedImage.naturalWidth / frame.uploadedImage.naturalHeight;
                        const targetRatio = targetWidth / targetHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (fitMode === 'cover') {
                            if (imgRatio > targetRatio) {
                                drawHeight = targetHeight;
                                drawWidth = drawHeight * imgRatio;
                            } else {
                                drawWidth = targetWidth;
                                drawHeight = drawWidth / imgRatio;
                            }
                            drawX = currentX + frame.transparentArea.x + (targetWidth - drawWidth) / 2;
                            drawY = frame.transparentArea.y + (targetHeight - drawHeight) / 2;
                        } else if (fitMode === 'contain') {
                            if (imgRatio > targetRatio) {
                                drawWidth = targetWidth;
                                drawHeight = drawWidth / imgRatio;
                            } else {
                                drawHeight = targetHeight;
                                drawWidth = drawHeight * imgRatio;
                            }
                            drawX = currentX + frame.transparentArea.x + (targetWidth - drawWidth) / 2;
                            drawY = frame.transparentArea.y + (targetHeight - drawHeight) / 2;
                        } else {
                            drawWidth = targetWidth;
                            drawHeight = targetHeight;
                            drawX = currentX + frame.transparentArea.x;
                            drawY = frame.transparentArea.y;
                        }
                        
                        drawX += frame.imageOffset.x;
                        drawY += frame.imageOffset.y;
                        
                        ctx.drawImage(frame.uploadedImage, drawX, drawY, drawWidth, drawHeight);
                    }
                    
                    ctx.drawImage(frame.frameImage, currentX, 0, frameWidth, frameHeight);
                    
                    currentX += frameWidth;
                }
            } else {
                // Renderizar molduras horizontais uma embaixo da outra
                let currentY = 0;
                for (let i = 0; i < frameCount; i++) {
                    const frame = frames[i];
                    if (!frame.frameImage) {
                        continue;
                    }
                    
                    const frameWidth = frame.frameImage.naturalWidth || frame.frameImage.width;
                    const frameHeight = frame.frameImage.naturalHeight || frame.frameImage.height;
                    
                    const bgMode = frame.bgMode || 'dominant';
                    let bgColor = '#FFFFFF';
                    if (bgMode === 'dominant') bgColor = frame.dominantColor || '#FFFFFF';
                    else if (bgMode === 'black') bgColor = '#000000';
                    else if (bgMode === 'white') bgColor = '#FFFFFF';
                    else if (bgMode === 'custom') bgColor = frame.customColor || '#FFFFFF';
                    
                    // Centralizar horizontalmente
                    const frameX = (canvasWidth - frameWidth) / 2;
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(frameX, currentY, frameWidth, frameHeight);
                    
                    if (frame.uploadedImage && frame.transparentArea) {
                        const fitMode = frame.fitMode || 'cover';
                        const targetWidth = frame.transparentArea.width;
                        const targetHeight = frame.transparentArea.height;
                        const imgRatio = frame.uploadedImage.naturalWidth / frame.uploadedImage.naturalHeight;
                        const targetRatio = targetWidth / targetHeight;
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (fitMode === 'cover') {
                            if (imgRatio > targetRatio) {
                                drawHeight = targetHeight;
                                drawWidth = drawHeight * imgRatio;
                            } else {
                                drawWidth = targetWidth;
                                drawHeight = drawWidth / imgRatio;
                            }
                            drawX = frameX + frame.transparentArea.x + (targetWidth - drawWidth) / 2;
                            drawY = currentY + frame.transparentArea.y + (targetHeight - drawHeight) / 2;
                        } else if (fitMode === 'contain') {
                            if (imgRatio > targetRatio) {
                                drawWidth = targetWidth;
                                drawHeight = drawWidth / imgRatio;
                            } else {
                                drawHeight = targetHeight;
                                drawWidth = drawHeight * imgRatio;
                            }
                            drawX = frameX + frame.transparentArea.x + (targetWidth - drawWidth) / 2;
                            drawY = currentY + frame.transparentArea.y + (targetHeight - drawHeight) / 2;
                        } else {
                            drawWidth = targetWidth;
                            drawHeight = targetHeight;
                            drawX = frameX + frame.transparentArea.x;
                            drawY = currentY + frame.transparentArea.y;
                        }
                        
                        drawX += frame.imageOffset.x;
                        drawY += frame.imageOffset.y;
                        
                        ctx.drawImage(frame.uploadedImage, drawX, drawY, drawWidth, drawHeight);
                    }
                    
                    ctx.drawImage(frame.frameImage, frameX, currentY, frameWidth, frameHeight);
                    
                    currentY += frameHeight;
                }
            }
        }

        function updateColorPickerVisibility() {
            const bgMode = document.getElementById('bgMode').value;
            const customGroup = document.getElementById('customColorGroup');
            customGroup.style.display = bgMode === 'custom' ? 'flex' : 'none';
        }

        function activateMoveMode() {
            if (!frames[activeFrameIndex].uploadedImage) {
                alert('Primeiro carregue uma imagem para poder mov√™-la.');
                return;
            }
            deactivateEyedropper();
            deactivateCropMode();
            isMoveModeActive = true;
            document.getElementById('moveBtn').classList.add('active');
            document.getElementById('canvas').style.cursor = 'move';
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', startMove);
            canvas.addEventListener('mousemove', doMove);
            canvas.addEventListener('mouseup', endMove);
            canvas.addEventListener('mouseleave', endMove);
        }

        function deactivateMoveMode() {
            isMoveModeActive = false;
            isDragging = false;
            document.getElementById('moveBtn').classList.remove('active');
            document.getElementById('canvas').style.cursor = 'default';
            const canvas = document.getElementById('canvas');
            canvas.removeEventListener('mousedown', startMove);
            canvas.removeEventListener('mousemove', doMove);
            canvas.removeEventListener('mouseup', endMove);
            canvas.removeEventListener('mouseleave', endMove);
        }

        function startMove(e) {
            if (!isMoveModeActive) return;
            e.preventDefault();
            isDragging = true;
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            dragStart.x = e.clientX - rect.left;
            dragStart.y = e.clientY - rect.top;
            currentDragOffset = { ...frames[activeFrameIndex].imageOffset };
        }

        function doMove(e) {
            if (!isMoveModeActive || !isDragging) return;
            e.preventDefault();
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            frames[activeFrameIndex].imageOffset.x = currentDragOffset.x + (currentX - dragStart.x) * scaleX;
            frames[activeFrameIndex].imageOffset.y = currentDragOffset.y + (currentY - dragStart.y) * scaleY;
            renderFinalCanvas();
        }

        function endMove() {
            if (!isMoveModeActive) return;
            isDragging = false;
        }

        function activateCropMode() {
            if (!frames[activeFrameIndex].uploadedImage) {
                alert('Primeiro carregue uma imagem para poder cort√°-la.');
                return;
            }
            deactivateEyedropper();
            deactivateMoveMode();
            isCropModeActive = true;
            document.getElementById('cropBtn').classList.add('active');
            document.getElementById('resetCropBtn').style.display = 'inline-flex';
            document.getElementById('cropHint').classList.add('active');
            document.getElementById('canvas').classList.add('crop-mode');
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', startCropSelection);
            canvas.addEventListener('mousemove', drawCropSelection);
            canvas.addEventListener('mouseup', endCropSelection);
            canvas.addEventListener('mouseleave', cancelCropSelection);
        }

        function deactivateCropMode() {
            isCropModeActive = false;
            isDrawingCrop = false;
            document.getElementById('cropBtn').classList.remove('active');
            document.getElementById('cropHint').classList.remove('active');
            document.getElementById('canvas').classList.remove('crop-mode');
            document.getElementById('cropOverlay').classList.remove('active');
            document.getElementById('cropOverlay').style.display = 'none';
            const canvas = document.getElementById('canvas');
            canvas.removeEventListener('mousedown', startCropSelection);
            canvas.removeEventListener('mousemove', drawCropSelection);
            canvas.removeEventListener('mouseup', endCropSelection);
            canvas.removeEventListener('mouseleave', cancelCropSelection);
        }

        function startCropSelection(e) {
            if (!isCropModeActive) return;
            e.preventDefault();
            isDrawingCrop = true;
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const firstFrameOrientation = frames[0].frameOrientation || 'vertical';
            
            if (firstFrameOrientation === 'vertical') {
                // Para layout horizontal (molduras verticais)
                let frameOffset = 0;
                for (let i = 0; i < activeFrameIndex; i++) {
                    if (frames[i].frameImage) {
                        frameOffset += frames[i].frameImage.naturalWidth || frames[i].frameImage.width;
                    }
                }
                
                cropStart.x = (e.clientX - rect.left) * scaleX;
                cropStart.y = (e.clientY - rect.top) * scaleY;
                
                const frameWidth = frames[activeFrameIndex].frameImage ? 
                    (frames[activeFrameIndex].frameImage.naturalWidth || frames[activeFrameIndex].frameImage.width) : 0;
                
                if (cropStart.x < frameOffset || cropStart.x > frameOffset + frameWidth) {
                    isDrawingCrop = false;
                    return;
                }
            } else {
                // Para layout vertical (molduras horizontais)
                let frameOffset = 0;
                for (let i = 0; i < activeFrameIndex; i++) {
                    if (frames[i].frameImage) {
                        frameOffset += frames[i].frameImage.naturalHeight || frames[i].frameImage.height;
                    }
                }
                
                cropStart.x = (e.clientX - rect.left) * scaleX;
                cropStart.y = (e.clientY - rect.top) * scaleY;
                
                const frameHeight = frames[activeFrameIndex].frameImage ? 
                    (frames[activeFrameIndex].frameImage.naturalHeight || frames[activeFrameIndex].frameImage.height) : 0;
                
                if (cropStart.y < frameOffset || cropStart.y > frameOffset + frameHeight) {
                    isDrawingCrop = false;
                    return;
                }
            }
            
            cropSelection = { x: cropStart.x, y: cropStart.y, width: 0, height: 0 };
            updateCropOverlay();
        }

        function drawCropSelection(e) {
            if (!isCropModeActive || !isDrawingCrop) return;
            e.preventDefault();
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;
            
            const firstFrameOrientation = frames[0].frameOrientation || 'vertical';
            
            if (firstFrameOrientation === 'vertical') {
                // Para layout horizontal (molduras verticais)
                let frameOffset = 0;
                for (let i = 0; i < activeFrameIndex; i++) {
                    if (frames[i].frameImage) {
                        frameOffset += frames[i].frameImage.naturalWidth || frames[i].frameImage.width;
                    }
                }
                
                const frameWidth = frames[activeFrameIndex].frameImage ? 
                    (frames[activeFrameIndex].frameImage.naturalWidth || frames[activeFrameIndex].frameImage.width) : 0;
                
                const limitedX = Math.max(frameOffset, Math.min(currentX, frameOffset + frameWidth));
                
                cropSelection.width = limitedX - cropStart.x;
                cropSelection.height = currentY - cropStart.y;
            } else {
                // Para layout vertical (molduras horizontais)
                let frameOffset = 0;
                for (let i = 0; i < activeFrameIndex; i++) {
                    if (frames[i].frameImage) {
                        frameOffset += frames[i].frameImage.naturalHeight || frames[i].frameImage.height;
                    }
                }
                
                const frameHeight = frames[activeFrameIndex].frameImage ? 
                    (frames[activeFrameIndex].frameImage.naturalHeight || frames[activeFrameIndex].frameImage.height) : 0;
                
                const limitedY = Math.max(frameOffset, Math.min(currentY, frameOffset + frameHeight));
                
                cropSelection.width = currentX - cropStart.x;
                cropSelection.height = limitedY - cropStart.y;
            }
            
            updateCropOverlay();
        }

        function endCropSelection() {
            if (!isCropModeActive || !isDrawingCrop) return;
            isDrawingCrop = false;
            if (cropSelection.width < 0) {
                cropSelection.x += cropSelection.width;
                cropSelection.width = -cropSelection.width;
            }
            if (cropSelection.height < 0) {
                cropSelection.y += cropSelection.height;
                cropSelection.height = -cropSelection.height;
            }
            if (cropSelection.width > 10 && cropSelection.height > 10) {
                applyCrop();
                // Remover overlay imediatamente
                cropSelection = null;
                document.getElementById('cropOverlay').classList.remove('active');
                document.getElementById('cropOverlay').style.display = 'none';
            } else {
                cancelCropSelection();
            }
        }

        function cancelCropSelection() {
            if (!isCropModeActive) return;
            isDrawingCrop = false;
            cropSelection = null;
            document.getElementById('cropOverlay').classList.remove('active');
            document.getElementById('cropOverlay').style.display = 'none';
        }

        function updateCropOverlay() {
            if (!cropSelection) return;
            const overlay = document.getElementById('cropOverlay');
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;
            let x = cropSelection.x * scaleX;
            let y = cropSelection.y * scaleY;
            let width = cropSelection.width * scaleX;
            let height = cropSelection.height * scaleY;
            if (width < 0) {
                x += width;
                width = -width;
            }
            if (height < 0) {
                y += height;
                height = -height;
            }
            overlay.style.left = x + 'px';
            overlay.style.top = y + 'px';
            overlay.style.width = width + 'px';
            overlay.style.height = height + 'px';
            overlay.style.display = 'block';
            overlay.classList.add('active');
        }

        function applyCrop() {
            const frameIndex = activeFrameIndex;
            const frame = frames[frameIndex];
            
            if (!frame.uploadedImage || !frame.transparentArea) return;
            
            const firstFrameOrientation = frames[0].frameOrientation || 'vertical';
            
            // Calcular offset da moldura ativa
            let frameOffsetX = 0;
            let frameOffsetY = 0;
            
            if (firstFrameOrientation === 'vertical') {
                // Para layout horizontal (molduras verticais)
                for (let i = 0; i < frameIndex; i++) {
                    if (frames[i].frameImage) {
                        frameOffsetX += frames[i].frameImage.naturalWidth || frames[i].frameImage.width;
                    }
                }
            } else {
                // Para layout vertical (molduras horizontais)
                for (let i = 0; i < frameIndex; i++) {
                    if (frames[i].frameImage) {
                        frameOffsetY += frames[i].frameImage.naturalHeight || frames[i].frameImage.height;
                    }
                }
                // Centralizar horizontalmente
                const frameWidth = frame.frameImage.naturalWidth || frame.frameImage.width;
                const canvasWidth = document.getElementById('canvas').width;
                frameOffsetX = (canvasWidth - frameWidth) / 2;
            }
            
            // Calcular a posi√ß√£o da imagem dentro da moldura
            const fitMode = frame.fitMode || 'cover';
            const targetWidth = frame.transparentArea.width;
            const targetHeight = frame.transparentArea.height;
            const imgRatio = frame.uploadedImage.naturalWidth / frame.uploadedImage.naturalHeight;
            const targetRatio = targetWidth / targetHeight;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (fitMode === 'cover') {
                if (imgRatio > targetRatio) {
                    drawHeight = targetHeight;
                    drawWidth = drawHeight * imgRatio;
                } else {
                    drawWidth = targetWidth;
                    drawHeight = drawWidth / imgRatio;
                }
                drawX = frameOffsetX + frame.transparentArea.x + (targetWidth - drawWidth) / 2;
                drawY = frameOffsetY + frame.transparentArea.y + (targetHeight - drawHeight) / 2;
            } else if (fitMode === 'contain') {
                if (imgRatio > targetRatio) {
                    drawWidth = targetWidth;
                    drawHeight = drawWidth / imgRatio;
                } else {
                    drawHeight = targetHeight;
                    drawWidth = drawHeight * imgRatio;
                }
                drawX = frameOffsetX + frame.transparentArea.x + (targetWidth - drawWidth) / 2;
                drawY = frameOffsetY + frame.transparentArea.y + (targetHeight - drawHeight) / 2;
            } else {
                drawWidth = targetWidth;
                drawHeight = targetHeight;
                drawX = frameOffsetX + frame.transparentArea.x;
                drawY = frameOffsetY + frame.transparentArea.y;
            }
            
            drawX += frame.imageOffset.x;
            drawY += frame.imageOffset.y;
            
            // Converter coordenadas do canvas para coordenadas da imagem original
            const scaleX = frame.uploadedImage.naturalWidth / drawWidth;
            const scaleY = frame.uploadedImage.naturalHeight / drawHeight;
            
            // Calcular coordenadas relativas √† imagem
            let imageCropX = (cropSelection.x - drawX) * scaleX;
            let imageCropY = (cropSelection.y - drawY) * scaleY;
            let imageCropWidth = cropSelection.width * scaleX;
            let imageCropHeight = cropSelection.height * scaleY;
            
            // Limitar o crop aos limites da imagem
            if (imageCropX < 0) {
                imageCropWidth += imageCropX;
                imageCropX = 0;
            }
            if (imageCropY < 0) {
                imageCropHeight += imageCropY;
                imageCropY = 0;
            }
            if (imageCropX + imageCropWidth > frame.uploadedImage.naturalWidth) {
                imageCropWidth = frame.uploadedImage.naturalWidth - imageCropX;
            }
            if (imageCropY + imageCropHeight > frame.uploadedImage.naturalHeight) {
                imageCropHeight = frame.uploadedImage.naturalHeight - imageCropY;
            }
            
            // Garantir dimens√µes m√≠nimas
            if (imageCropWidth < 1 || imageCropHeight < 1) {
                // Se n√£o houver √°rea v√°lida, cancelar o crop
                cropSelection = null;
                document.getElementById('cropOverlay').classList.remove('active');
                document.getElementById('cropOverlay').style.display = 'none';
                return;
            }
            
            // Criar canvas tempor√°rio para o crop
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCanvas.width = imageCropWidth;
            croppedCanvas.height = imageCropHeight;
            
            // Desenhar apenas a parte cortada da imagem original
            croppedCtx.drawImage(
                frame.uploadedImage,
                imageCropX, imageCropY,
                imageCropWidth, imageCropHeight,
                0, 0,
                imageCropWidth, imageCropHeight
            );
            
            // Criar nova imagem
            const newImage = new Image();
            newImage.onload = function() {
                frames[frameIndex].uploadedImage = newImage;
                frames[frameIndex].currentCrop = {
                    x: imageCropX,
                    y: imageCropY,
                    width: imageCropWidth,
                    height: imageCropHeight
                };
                renderFinalCanvas();
                
                // Mostrar bot√£o resetCropBtn
                document.getElementById('resetCropBtn').style.display = 'inline-flex';
            };
            newImage.src = croppedCanvas.toDataURL('image/png');
        }

        function resetCrop() {
            const frame = frames[activeFrameIndex];
            if (!frame || !frame.originalImage) {
                alert('Nenhuma imagem original dispon√≠vel para restaurar.');
                return;
            }
            
            // Criar uma c√≥pia da imagem original
            const restoredImage = new Image();
            restoredImage.onload = function() {
                // Substituir a imagem atual pela original
                frames[activeFrameIndex].uploadedImage = restoredImage;
                frames[activeFrameIndex].currentCrop = null;
                frames[activeFrameIndex].imageOffset = { x: 0, y: 0 };
                
                // Esconder bot√£o resetCropBtn
                document.getElementById('resetCropBtn').style.display = 'none';
                
                // Recriar a imagem original (nova refer√™ncia)
                frames[activeFrameIndex].originalImage = new Image();
                frames[activeFrameIndex].originalImage.src = restoredImage.src;
                
                // Atualizar o canvas
                renderFinalCanvas();
            };
            restoredImage.onerror = function() {
                alert('Erro ao restaurar a imagem original.');
            };
            
            // Usar a imagem original armazenada
            restoredImage.src = frame.originalImage.src;
        }

        function activateEyedropper() {
            if ('EyeDropper' in window) {
                const eyeDropper = new EyeDropper();
                eyeDropper.open().then(result => {
                    customColor = result.sRGBHex.toUpperCase();
                    document.getElementById('colorInput').value = customColor;
                    document.getElementById('colorDisplay').style.backgroundColor = customColor;
                    if (frames[activeFrameIndex]) {
                        frames[activeFrameIndex].customColor = customColor;
                    }
                    renderFinalCanvas();
                }).catch(e => {
                    console.log('Conta-gotas cancelado');
                });
                return;
            }
            
            if (!frames[activeFrameIndex].uploadedImage) {
                alert('Primeiro carregue uma imagem para usar o conta-gotas.');
                return;
            }
            
            deactivateMoveMode();
            deactivateCropMode();
            isEyedropperActive = true;
            document.getElementById('eyedropperBtn').classList.add('active');
            document.getElementById('eyedropperHint').classList.add('active');
            document.getElementById('canvas').classList.add('eyedropper-mode');
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('click', handleCanvasClick);
            document.addEventListener('keydown', handleEyedropperKeydown);
        }

        function deactivateEyedropper() {
            isEyedropperActive = false;
            document.getElementById('eyedropperBtn').classList.remove('active');
            document.getElementById('eyedropperHint').classList.remove('active');
            document.getElementById('canvas').classList.remove('eyedropper-mode');
            const canvas = document.getElementById('canvas');
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('click', handleCanvasClick);
            document.removeEventListener('keydown', handleEyedropperKeydown);
        }

        function handleCanvasMouseMove(e) {
            if (!isEyedropperActive) return;
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                document.getElementById('canvas').style.cursor = 'crosshair';
            }
        }

        function handleCanvasClick(e) {
            if (!isEyedropperActive) return;
            e.preventDefault();
            e.stopPropagation();
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                const ctx = canvas.getContext('2d');
                const pixelData = ctx.getImageData(x, y, 1, 1).data;
                const color = rgbToHex(pixelData[0], pixelData[1], pixelData[2]);
                customColor = color;
                document.getElementById('colorInput').value = customColor;
                document.getElementById('colorDisplay').style.backgroundColor = customColor;
                if (frames[activeFrameIndex]) {
                    frames[activeFrameIndex].customColor = customColor;
                }
                renderFinalCanvas();
            }
            deactivateEyedropper();
        }

        function handleEyedropperKeydown(e) {
            if (e.key === 'Escape') deactivateEyedropper();
        }

        function updateFilenamePreview() {
            const prefix = document.getElementById('filePrefix').value.trim();
            const articleName = document.getElementById('articleName').value.trim();
            const preview = document.getElementById('filenamePreview');
            if (!articleName) {
                preview.innerHTML = '<span class="placeholder" style="color: #999;">Digite o nome do artigo</span>';
                return;
            }
            const cleanPrefix = prefix.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            const cleanArticle = articleName.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            let finalName = '';
            if (cleanPrefix && cleanArticle) {
                finalName = `${cleanPrefix}<span class="separator">-</span>${cleanArticle}.png`;
            } else if (cleanArticle) {
                finalName = `${cleanArticle}.png`;
            } else {
                finalName = '<span class="placeholder" style="color: #999;">Digite o nome do artigo</span>';
            }
            preview.innerHTML = finalName;
        }

        function generateFileName() {
            const prefix = document.getElementById('filePrefix').value.trim();
            const articleName = document.getElementById('articleName').value.trim();
            if (!articleName) return 'imagem-enquadrada';
            const cleanPrefix = prefix.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            const cleanArticle = articleName.replace(/[^a-zA-Z0-9-_]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            if (cleanPrefix && cleanArticle) return `${cleanPrefix}-${cleanArticle}`;
            else if (cleanArticle) return cleanArticle;
            else return 'imagem-enquadrada';
        }

        function downloadImage() {
            const canvas = document.getElementById('canvas');
            const fileName = generateFileName();
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = fileName + '.png';
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }

        function resetAll() {
            frameCount = 1;
            frames = [];
            selectedPortal = '';
            isCustomFrame = false;
            customColor = '#FFFFFF';
            activeFrameIndex = 0;
            document.getElementById('imageUpload').value = '';
            document.getElementById('frameUpload').value = '';
            document.getElementById('filePrefix').value = '';
            document.getElementById('articleName').value = '';
            document.getElementById('portalSelect').value = '';
            document.getElementById('colorInput').value = customColor;
            document.getElementById('colorDisplay').style.backgroundColor = customColor;
            updateFilenamePreview();
            document.getElementById('imageBox').classList.remove('has-file');
            document.getElementById('frameBox').classList.remove('has-file');
            document.getElementById('frameBox').style.display = 'none';
            document.getElementById('singleUploadSection').classList.add('single-column');
            document.getElementById('singleUploadSection').style.display = 'none';
            document.getElementById('multiImageUploads').classList.remove('active');
            document.getElementById('frameCountSelector').classList.remove('active');
            document.getElementById('imageLabel').textContent = 'Sua Imagem';
            document.getElementById('frameLabel').textContent = 'Moldura PNG';
            document.getElementById('previewSection').classList.remove('active');
            document.getElementById('fitMode').value = 'cover';
            document.getElementById('bgMode').value = 'dominant';
            document.getElementById('customColorGroup').style.display = 'none';
            document.getElementById('resetCropBtn').style.display = 'none';
            deactivateEyedropper();
            deactivateMoveMode();
            deactivateCropMode();
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.querySelectorAll('.frame-count-btn').forEach((btn, idx) => {
                if (idx === 0) btn.classList.add('active');
                else btn.classList.remove('active');
            });
            
            initializeFrames(1);
        }

        // Event listeners para os upload boxes
        document.getElementById('imageBox').addEventListener('click', function() {
            document.getElementById('imageUpload').click();
        });

        document.getElementById('frameBox').addEventListener('click', function() {
            document.getElementById('frameUpload').click();
        });

        document.getElementById('colorInput').addEventListener('input', function() {
            let value = this.value;
            if (value.length <= 7) {
                if (value.length > 0 && !value.startsWith('#')) {
                    value = '#' + value;
                    this.value = value;
                }
                this.value = value.toUpperCase();
            }
        });

        document.getElementById('colorInput').addEventListener('blur', function() {
            let color = this.value.trim().toUpperCase();
            if (!color.startsWith('#')) color = '#' + color;
            const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
            if (hexRegex.test(color)) {
                if (color.length === 4) color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
                customColor = color;
                this.value = customColor;
                document.getElementById('colorDisplay').style.backgroundColor = customColor;
                if (frames[activeFrameIndex]) {
                    frames[activeFrameIndex].customColor = customColor;
                }
                renderFinalCanvas();
            } else {
                this.value = customColor;
            }
        });

        document.getElementById('colorDisplay').addEventListener('click', function() {
            document.getElementById('colorInput').focus();
            document.getElementById('colorInput').select();
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (isEyedropperActive) deactivateEyedropper();
                if (isCropModeActive) {
                    deactivateCropMode();
                    document.getElementById('cropOverlay').classList.remove('active');
                    document.getElementById('cropOverlay').style.display = 'none';
                }
            }
        });

        // Fun√ß√£o para upload de imagem (modo single/custom)
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        const index = 0;
                        
                        if (frames.length === 0) {
                            initializeFrames(1);
                        }
                        
                        frames[index].uploadedImage = img;
                        frames[index].originalImage = new Image();
                        frames[index].originalImage.src = img.src;
                        frames[index].imageOffset = { x: 0, y: 0 };
                        frames[index].currentCrop = null;
                        
                        document.getElementById('imageBox').classList.add('has-file');
                        document.getElementById('imageLabel').textContent = '‚úì Imagem Carregada';
                        
                        extractDominantColor(img, index);
                        
                        const isHorizontal = detectImageOrientation(img);
                        frames[index].isVertical = !isHorizontal;
                        
                        // Mostrar bot√£o resetCropBtn
                        document.getElementById('resetCropBtn').style.display = 'inline-flex';
                        
                        // Para modo custom, verificar se j√° temos moldura
                        if (selectedPortal === 'custom') {
                            if (frames[index].frameImage) {
                                checkAllImagesReady();
                            } else {
                                alert('Agora fa√ßa upload da moldura PNG.');
                            }
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Fun√ß√£o para upload de moldura personalizada
        document.getElementById('frameUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        const index = 0;
                        
                        if (frames.length === 0) {
                            initializeFrames(1);
                        }
                        
                        frames[index].frameImage = img;
                        // Determinar orienta√ß√£o da moldura
                        const isFrameHorizontal = img.naturalWidth > img.naturalHeight;
                        frames[index].frameOrientation = isFrameHorizontal ? 'horizontal' : 'vertical';
                        
                        document.getElementById('frameBox').classList.add('has-file');
                        document.getElementById('frameLabel').textContent = '‚úì Moldura Carregada';
                        
                        document.getElementById('status').classList.add('active');
                        
                        setTimeout(() => {
                            detectTransparentArea(index);
                            
                            if (frames[index].uploadedImage) {
                                checkAllImagesReady();
                            } else {
                                renderFinalCanvas();
                                document.getElementById('previewSection').classList.add('active');
                                updateFrameSelector();
                                loadFrameSettings();
                            }
                            
                            document.getElementById('status').classList.remove('active');
                        }, 500);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Inicializar
        window.addEventListener('DOMContentLoaded', function() {
            document.getElementById('portalSelect').value = '';
            updatePortalSelection();
            initializeFrames(1);
        });
        
        updateColorPickerVisibility();
        updateFilenamePreview();
        initializeFrames(1);
    </script>

</body>
</html>
